name: üì¶ Release et Changelog PCR

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write
  pull-requests: read

jobs:
  release:
    name: üöÄ Create Release and Deploy Changelog
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: üì¶ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: üìã Install dependencies
        run: npm ci
        
      - name: üèóÔ∏è Build and prepare
        run: |
          echo "üèóÔ∏è Pr√©paration de la release..."
          npm audit fix --force || true
          
      - name: üìù Extract version and prepare release notes
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Version d√©tect√©e: $VERSION"
          
          # G√©n√©rer les notes de release depuis changelog.json
          if [ -f "changelog.json" ]; then
            echo "üìã G√©n√©ration des notes depuis changelog.json..."
            node -e "
              const fs = require('fs');
              try {
                const changelog = JSON.parse(fs.readFileSync('changelog.json', 'utf8'));
                const release = changelog.releases.find(r => r.version === '$VERSION');
                
                if (release) {
                  let notes = \`## üéâ \${release.title || 'Release ' + release.version}\\n\\n\`;
                  
                  if (release.features && release.features.length > 0) {
                    const featuresByType = release.features.reduce((acc, f) => {
                      if (!acc[f.type]) acc[f.type] = [];
                      acc[f.type].push(f);
                      return acc;
                    }, {});
                    
                    Object.entries(featuresByType).forEach(([type, features]) => {
                      const typeTitle = {
                        'command': '‚ö° Nouvelles Commandes',
                        'event': 'üéØ Nouveaux √âv√©nements', 
                        'feature': '‚ú® Nouvelles Fonctionnalit√©s',
                        'fix': 'üêõ Corrections',
                        'enhancement': 'üîß Am√©liorations'
                      }[type] || 'üìã Autres';
                      
                      notes += \`### \${typeTitle}\\n\\n\`;
                      features.forEach(f => {
                        notes += \`- **\${f.name}**: \${f.description}\`;
                        if (f.author) notes += \` (par \${f.author})\`;
                        notes += \`\\n\`;
                      });
                      notes += \`\\n\`;
                    });
                  }
                  
                  notes += \`### üöÄ Installation rapide\\n\\n\`;
                  notes += \`\\\`\\\`\\\`bash\\n\`;
                  notes += \`git clone https://github.com/sydnec/PCR.git\\n\`;
                  notes += \`cd PCR\\n\`;
                  notes += \`./pcr deploy\\n\`;
                  notes += \`\\\`\\\`\\\`\\n\`;
                  
                  fs.writeFileSync('RELEASE_NOTES.md', notes);
                  console.log('‚úÖ Notes de release g√©n√©r√©es depuis changelog.json');
                } else {
                  throw new Error('Release non trouv√©e dans changelog.json');
                }
              } catch (error) {
                console.log('‚ö†Ô∏è Erreur avec changelog.json, utilisation du fallback:', error.message);
                const fallback = \`## üéâ PCR Bot v\${process.env.VERSION}\\n\\nNouvelle version du bot Discord PCR.\\n\\n### üöÄ Installation\\n\\n\\\`\\\`\\\`bash\\ngit clone https://github.com/sydnec/PCR.git\\ncd PCR\\n./pcr deploy\\n\\\`\\\`\\\`\`;
                require('fs').writeFileSync('RELEASE_NOTES.md', fallback);
              }
            "
          else
            echo "‚ö†Ô∏è changelog.json non trouv√©, g√©n√©ration de notes basiques..."
            cat > RELEASE_NOTES.md << EOF
          ## üéâ PCR Bot v$VERSION
          
          Nouvelle version du bot Discord PCR.
          
          ### üöÄ Installation rapide
          
          \`\`\`bash
          git clone https://github.com/sydnec/PCR.git
          cd PCR
          ./pcr deploy
          \`\`\`
          EOF
          fi
          
      - name: üì¶ Create Release Archive
        run: |
          echo "üì¶ Cr√©ation de l'archive de release..."
          # Cr√©er un r√©pertoire temporaire pour l'archive
          mkdir -p /tmp/pcr-release
          
          # Copier les fichiers n√©cessaires en excluant les r√©pertoires/fichiers ind√©sirables
          rsync -av --progress \
            --exclude='.git/' \
            --exclude='node_modules/' \
            --exclude='.github/' \
            --exclude='backups/' \
            --exclude='logs/' \
            --exclude='*.db' \
            --exclude='.env' \
            --exclude='*.tar.gz' \
            --exclude='/tmp/' \
            ./ /tmp/pcr-release/
          
          # Cr√©er l'archive depuis le r√©pertoire temporaire
          cd /tmp
          tar -czf pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz pcr-release/
          
          # D√©placer l'archive vers le r√©pertoire de travail
          mv pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz $GITHUB_WORKSPACE/
          
          # Nettoyer le r√©pertoire temporaire
          rm -rf /tmp/pcr-release
          
          echo "‚úÖ Archive cr√©√©e: pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz"
            
      - name: üöÄ Create GitHub Release
        id: create_release
        run: |
          echo "üöÄ Cr√©ation de la release GitHub..."
          
          # Cr√©er la release avec GitHub CLI
          gh release create "v${{ steps.version.outputs.VERSION }}" \
            --title "ü§ñ PCR Bot v${{ steps.version.outputs.VERSION }}" \
            --notes-file RELEASE_NOTES.md \
            --target main \
            ./pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz
          
          echo "‚úÖ Release v${{ steps.version.outputs.VERSION }} cr√©√©e avec succ√®s"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: üöÄ Deploy to Production Server
        id: deploy
        run: |
          echo "üöÄ D√©ploiement automatique sur le serveur de production..."
          
          # Configuration SSH
          mkdir -p ~/.ssh
          echo "${{ secrets.PROD_SSH_KEY }}" > ~/.ssh/prod_key
          chmod 600 ~/.ssh/prod_key
          
          # Ajouter l'h√¥te aux known_hosts pour √©viter les prompts
          ssh-keyscan -H ${{ secrets.PROD_SSH_HOST }} >> ~/.ssh/known_hosts
          
          # Script de d√©ploiement sur le serveur distant
          ssh -i ~/.ssh/prod_key ${{ secrets.PROD_SSH_USER }}@${{ secrets.PROD_SSH_HOST }} << 'EOF'
            set -e
            echo "üìç Connexion au serveur de production √©tablie"
            
            # Naviguer vers le r√©pertoire du projet
            cd ${{ secrets.PROD_PROJECT_PATH || '/home/sydnec/PCR' }}
            echo "üìÅ R√©pertoire de projet: $(pwd)"
            
            # Sauvegarder l'√©tat actuel
            echo "üíæ Sauvegarde de l'√©tat actuel..."
            git stash push -m "Auto-stash before deployment $(date)" || echo "Rien √† sauvegarder"
            
            # R√©cup√©rer les derni√®res modifications et tags
            echo "üì• R√©cup√©ration des derni√®res modifications..."
            git fetch origin --tags
            
            # Basculer vers le nouveau tag
            echo "üè∑Ô∏è Basculement vers le tag v${{ steps.version.outputs.VERSION }}..."
            git checkout v${{ steps.version.outputs.VERSION }}
            
            # Mettre √† jour les d√©pendances si n√©cessaire
            if git diff HEAD~1 HEAD --name-only | grep -q package.json; then
              echo "üì¶ package.json modifi√©, mise √† jour des d√©pendances..."
              npm install
            fi
            
            # Red√©marrer le bot avec PM2
            echo "üîÑ Red√©marrage du bot PCR..."
            pm2 restart pcr || {
              echo "‚ö†Ô∏è Erreur lors du restart, tentative de start..."
              pm2 start index.js --name pcr
            }
            
            # Sauvegarder la configuration PM2
            pm2 save
            
            # V√©rifier que le bot est en ligne
            sleep 5
            if pm2 list | grep -q "pcr.*online"; then
              echo "‚úÖ Bot PCR red√©marr√© avec succ√®s sur la version v${{ steps.version.outputs.VERSION }}"
            else
              echo "‚ùå Erreur: Le bot n'est pas en ligne apr√®s le red√©marrage"
              pm2 logs pcr --lines 10
              exit 1
            fi
            
            echo "üéâ D√©ploiement automatique termin√© avec succ√®s !"
          EOF
          
          # Nettoyer la cl√© SSH
          rm -f ~/.ssh/prod_key
          
          echo "‚úÖ D√©ploiement automatique r√©ussi sur le serveur de production"
        env:
          SSH_AUTH_SOCK: /tmp/ssh_agent.sock

      - name: ‚úÖ Release Summary
        if: success()
        run: |
          echo "üéâ Release v${{ steps.version.outputs.VERSION }} cr√©√©e et d√©ploy√©e avec succ√®s !"
          echo ""
          echo "üìã R√©sum√©:"
          echo "  ‚Ä¢ Version: ${{ steps.version.outputs.VERSION }}"
          echo "  ‚Ä¢ Tag: v${{ steps.version.outputs.VERSION }}"
          echo "  ‚Ä¢ Archive: pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz"
          echo "  ‚Ä¢ Release GitHub: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.VERSION }}"
          echo "  ‚Ä¢ D√©ploiement: ‚úÖ Automatique sur serveur de production"
          echo ""
          echo "üöÄ Actions automatiques r√©alis√©es:"
          echo "  ‚Ä¢ ‚úÖ Release GitHub cr√©√©e"
          echo "  ‚Ä¢ ‚úÖ Code d√©ploy√© sur le serveur de production"
          echo "  ‚Ä¢ ‚úÖ Bot PCR red√©marr√© avec la nouvelle version"
          echo "  ‚Ä¢ ‚úÖ Notifications Discord pr√™tes (si configur√©es)"
          echo ""
          echo "üí° Le bot est maintenant op√©rationnel avec la version v${{ steps.version.outputs.VERSION }}"
          
      - name: ‚ùå Deploy Failure Notification
        if: failure()
        run: |
          echo "‚ùå √âchec du d√©ploiement de la version v${{ steps.version.outputs.VERSION }}"
          echo ""
          echo "üîç V√©rifications n√©cessaires:"
          echo "  ‚Ä¢ Connexion SSH au serveur de production"
          echo "  ‚Ä¢ Configuration des secrets GitHub"
          echo "  ‚Ä¢ √âtat du serveur et de PM2"
          echo ""
          echo "üìû Action manuelle requise pour finaliser le d√©ploiement"

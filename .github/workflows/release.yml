name: ðŸ“¦ Release et Changelog PCR

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    name: ðŸš€ Create Release and Deploy Changelog
    runs-on: ubuntu-latest
    
    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          
      - name: ðŸ“‹ Install dependencies
        run: npm ci
        
      - name: ðŸ—ï¸ Build and prepare
        run: |
          echo "ðŸ—ï¸ PrÃ©paration de la release..."
          npm audit fix --force || true
          
      - name: ðŸ“ Extract version and prepare release notes
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸ Version dÃ©tectÃ©e: $VERSION"
          
          # GÃ©nÃ©rer les notes de release depuis changelog.json
          if [ -f "changelog.json" ]; then
            echo "ðŸ“‹ GÃ©nÃ©ration des notes depuis changelog.json..."
            node -e "
              const fs = require('fs');
              try {
                const changelog = JSON.parse(fs.readFileSync('changelog.json', 'utf8'));
                const release = changelog.releases.find(r => r.version === '$VERSION');
                
                if (release) {
                  let notes = \`## ðŸŽ‰ \${release.title || 'Release ' + release.version}\\n\\n\`;
                  
                  if (release.features && release.features.length > 0) {
                    const featuresByType = release.features.reduce((acc, f) => {
                      if (!acc[f.type]) acc[f.type] = [];
                      acc[f.type].push(f);
                      return acc;
                    }, {});
                    
                    Object.entries(featuresByType).forEach(([type, features]) => {
                      const typeTitle = {
                        'command': 'âš¡ Nouvelles Commandes',
                        'event': 'ðŸŽ¯ Nouveaux Ã‰vÃ©nements', 
                        'feature': 'âœ¨ Nouvelles FonctionnalitÃ©s',
                        'fix': 'ðŸ› Corrections',
                        'enhancement': 'ðŸ”§ AmÃ©liorations'
                      }[type] || 'ðŸ“‹ Autres';
                      
                      notes += \`### \${typeTitle}\\n\\n\`;
                      features.forEach(f => {
                        notes += \`- **\${f.name}**: \${f.description}\`;
                        if (f.author) notes += \` (par \${f.author})\`;
                        notes += \`\\n\`;
                      });
                      notes += \`\\n\`;
                    });
                  }
                  
                  notes += \`### ðŸš€ Installation rapide\\n\\n\`;
                  notes += \`\\\`\\\`\\\`bash\\n\`;
                  notes += \`git clone https://github.com/sydnec/PCR.git\\n\`;
                  notes += \`cd PCR\\n\`;
                  notes += \`./pcr deploy\\n\`;
                  notes += \`\\\`\\\`\\\`\\n\`;
                  
                  fs.writeFileSync('RELEASE_NOTES.md', notes);
                  console.log('âœ… Notes de release gÃ©nÃ©rÃ©es depuis changelog.json');
                } else {
                  throw new Error('Release non trouvÃ©e dans changelog.json');
                }
              } catch (error) {
                console.log('âš ï¸ Erreur avec changelog.json, utilisation du fallback:', error.message);
                const fallback = \`## ðŸŽ‰ PCR Bot v\${process.env.VERSION}\\n\\nNouvelle version du bot Discord PCR.\\n\\n### ðŸš€ Installation\\n\\n\\\`\\\`\\\`bash\\ngit clone https://github.com/sydnec/PCR.git\\ncd PCR\\n./pcr deploy\\n\\\`\\\`\\\`\`;
                require('fs').writeFileSync('RELEASE_NOTES.md', fallback);
              }
            "
          else
            echo "âš ï¸ changelog.json non trouvÃ©, gÃ©nÃ©ration de notes basiques..."
            cat > RELEASE_NOTES.md << EOF
          ## ðŸŽ‰ PCR Bot v$VERSION
          
          Nouvelle version du bot Discord PCR.
          
          ### ðŸš€ Installation rapide
          
          \`\`\`bash
          git clone https://github.com/sydnec/PCR.git
          cd PCR
          ./pcr deploy
          \`\`\`
          EOF
          fi
          
      - name: ðŸ“¦ Create Release Archive
        run: |
          echo "ðŸ“¦ CrÃ©ation de l'archive de release..."
          tar -czf pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='.github' \
            --exclude='backups' \
            --exclude='logs' \
            --exclude='*.db' \
            --exclude='.env' \
            .
            
      - name: ðŸš€ Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.version.outputs.VERSION }}
          release_name: ðŸ¤– PCR Bot v${{ steps.version.outputs.VERSION }}
          body_path: RELEASE_NOTES.md
          draft: false
          prerelease: false
          
      - name: ðŸ“Ž Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz
          asset_name: pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz
          asset_content_type: application/gzip

      - name: ðŸ“¢ Send Discord Changelog Notification
        if: success()
        run: |
          echo "ðŸ“¢ Envoi de la notification Discord..."
          
          # Script Node.js pour envoyer le changelog Ã  Discord
          cat > discord_notification.js << 'EOF'
          const https = require('https');
          const fs = require('fs');
          
          async function sendDiscordNotification() {
            try {
              const webhookUrl = process.env.DISCORD_CHANGELOG_WEBHOOK;
              if (!webhookUrl) {
                console.log('âš ï¸ DISCORD_CHANGELOG_WEBHOOK non configurÃ©, notification ignorÃ©e');
                return;
              }
              
              const version = process.env.VERSION;
              let embed = {
                title: `ðŸš€ PCR Bot v${version} dÃ©ployÃ© !`,
                description: `Nouvelle version du PCR Bot dÃ©ployÃ©e automatiquement via GitHub Actions.`,
                color: 0x00ff00,
                timestamp: new Date().toISOString(),
                footer: {
                  text: 'DÃ©ploiement automatique GitHub Actions',
                  icon_url: 'https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png'
                },
                fields: []
              };
              
              // Lire le changelog si disponible
              if (fs.existsSync('changelog.json')) {
                try {
                  const changelog = JSON.parse(fs.readFileSync('changelog.json', 'utf8'));
                  const release = changelog.releases.find(r => r.version === version);
                  
                  if (release && release.features) {
                    embed.description = `${release.title || `Release ${version}`}\n\n${release.features.length} nouvelle(s) fonctionnalitÃ©(s) incluse(s).`;
                    
                    const featuresByType = release.features.reduce((acc, feature) => {
                      if (!acc[feature.type]) acc[feature.type] = [];
                      acc[feature.type].push(feature);
                      return acc;
                    }, {});
                    
                    Object.entries(featuresByType).forEach(([type, features]) => {
                      const typeTitle = {
                        'command': 'âš¡ Nouvelles Commandes',
                        'event': 'ðŸŽ¯ Nouveaux Ã‰vÃ©nements',
                        'feature': 'âœ¨ Nouvelles FonctionnalitÃ©s',
                        'fix': 'ðŸ› Corrections',
                        'enhancement': 'ðŸ”§ AmÃ©liorations'
                      }[type] || 'ðŸ“‹ Autres';
                      
                      const featureList = features.map(f => `â€¢ **${f.name}**: ${f.description}`).join('\n');
                      
                      embed.fields.push({
                        name: typeTitle,
                        value: featureList.length > 1024 ? featureList.substring(0, 1020) + '...' : featureList,
                        inline: false
                      });
                    });
                  }
                } catch (error) {
                  console.log('âš ï¸ Erreur lors de la lecture du changelog:', error.message);
                }
              }
              
              // Ajouter des liens utiles
              embed.fields.push({
                name: 'ðŸ”— Liens',
                value: `â€¢ [Voir la release](https://github.com/${process.env.GITHUB_REPOSITORY}/releases/tag/v${version})\nâ€¢ [Code source](https://github.com/${process.env.GITHUB_REPOSITORY})`,
                inline: false
              });
              
              const payload = JSON.stringify({ embeds: [embed] });
              
              const url = new URL(webhookUrl);
              const options = {
                hostname: url.hostname,
                path: url.pathname + url.search,
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Content-Length': Buffer.byteLength(payload)
                }
              };
              
              return new Promise((resolve, reject) => {
                const req = https.request(options, (res) => {
                  console.log(`ðŸ“¢ Discord webhook status: ${res.statusCode}`);
                  if (res.statusCode >= 200 && res.statusCode < 300) {
                    console.log('âœ… Notification Discord envoyÃ©e avec succÃ¨s');
                    resolve();
                  } else {
                    reject(new Error(`HTTP ${res.statusCode}`));
                  }
                });
                
                req.on('error', reject);
                req.write(payload);
                req.end();
              });
              
            } catch (error) {
              console.error('âŒ Erreur notification Discord:', error.message);
            }
          }
          
          sendDiscordNotification();
          EOF
          
          # ExÃ©cuter la notification
          node discord_notification.js
        env:
          DISCORD_CHANGELOG_WEBHOOK: ${{ secrets.DISCORD_CHANGELOG_WEBHOOK }}
          VERSION: ${{ steps.version.outputs.VERSION }}
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: âœ… Release Summary
        if: success()
        run: |
          echo "ðŸŽ‰ Release v${{ steps.version.outputs.VERSION }} crÃ©Ã©e avec succÃ¨s !"
          echo ""
          echo "ðŸ“‹ RÃ©sumÃ©:"
          echo "  â€¢ Version: ${{ steps.version.outputs.VERSION }}"
          echo "  â€¢ Tag: v${{ steps.version.outputs.VERSION }}"
          echo "  â€¢ Archive: pcr-bot-v${{ steps.version.outputs.VERSION }}.tar.gz"
          echo "  â€¢ Release GitHub: https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.VERSION }}"
          echo ""
          echo "ðŸ’¡ Prochaines Ã©tapes:"
          echo "  â€¢ La notification Discord a Ã©tÃ© envoyÃ©e (si configurÃ©e)"
          echo "  â€¢ Les utilisateurs peuvent maintenant tÃ©lÃ©charger la nouvelle version"
          echo "  â€¢ Le changelog est automatiquement publiÃ©"

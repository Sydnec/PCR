#!/bin/bash

# ü§ñ PCR Bot Discord - Script de gestion unifi√©
# Usage: pcr [command]

# Auto-d√©tection du r√©pertoire du projet
# Si le script est dans /usr/local/bin, on utilise le r√©pertoire courant
# Sinon, on utilise le r√©pertoire du script

if [[ "$(realpath "$0")" == "/usr/local/bin/pcr" ]]; then
    # Script install√© globalement, utiliser le r√©pertoire courant
    PROJECT_DIR="$(pwd)"
    # V√©rifier si on est dans un projet PCR valide
    if [[ ! -f "index.js" ]] || [[ ! -f "package.json" ]]; then
        # Essayer de trouver le projet dans les r√©pertoires parents
        current_dir="$(pwd)"
        found=false
        while [[ "$current_dir" != "/" ]]; do
            if [[ -f "$current_dir/index.js" ]] && [[ -f "$current_dir/package.json" ]] && [[ -f "$current_dir/pcr" ]]; then
                PROJECT_DIR="$current_dir"
                found=true
                break
            fi
            current_dir="$(dirname "$current_dir")"
        done
        
        if [[ "$found" != true ]]; then
            PROJECT_DIR="/home/sydnec/PCR"  # Fallback
        fi
    fi
else
    # Script local, utiliser le r√©pertoire du script
    PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

LOG_DIR="$PROJECT_DIR/logs"
BACKUP_DIR="$PROJECT_DIR/backups"

# Validation du r√©pertoire de projet
validate_project_directory() {
    if [[ ! -f "$PROJECT_DIR/index.js" ]] || [[ ! -f "$PROJECT_DIR/package.json" ]]; then
        print_error "Ce r√©pertoire ne semble pas √™tre un projet PCR valide."
        print_error "Fichiers attendus :"
        print_error "  - index.js: $PROJECT_DIR/index.js"
        print_error "  - package.json: $PROJECT_DIR/package.json"
        print_error ""
        print_error "R√©pertoire actuel d√©tect√© : $PROJECT_DIR"
        print_error "Assurez-vous d'√™tre dans le r√©pertoire racine du projet ou que les fichiers existent."
        exit 1
    fi
}

# Cr√©ation du r√©pertoire de backup si n√©cessaire
ensure_backup_dir() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
}

# Cr√©ation du r√©pertoire de logs si n√©cessaire
ensure_log_dir() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
    fi
}

# Fonction pour trouver le chemin de la base de donn√©es
find_database_path() {
    local db_paths=(
        "$PROJECT_DIR/messages.db"
        "$PROJECT_DIR/database.db"
        "$PROJECT_DIR/bot.db"
    )
    
    for path in "${db_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Retourner le chemin standard si aucun fichier trouv√©
    echo "$PROJECT_DIR/messages.db"
    return 1
}

# Fonction de sauvegarde de la base de donn√©es
backup_database() {
    ensure_backup_dir
    local backup_file="$BACKUP_DIR/db_backup_$(date +%Y%m%d_%H%M%S).db"
    local db_path
    
    db_path=$(find_database_path)
    
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "$backup_file"
        print_success "Base de donn√©es sauvegard√©e : $backup_file"
        print_success "Source: $db_path"
        return 0
    else
        print_warning "Aucune base de donn√©es trouv√©e"
        print_warning "Emplacements v√©rifi√©s:"
        print_warning "  - $PROJECT_DIR/messages.db"
        print_warning "  - $PROJECT_DIR/database.db"
        print_warning "  - $PROJECT_DIR/bot.db"
        return 1
    fi
}

# Fonction de restauration de la base de donn√©es
restore_database() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        print_error "Fichier de sauvegarde requis"
        echo "Usage: pcr restore <fichier_backup>"
        echo "Sauvegardes disponibles:"
        ls -la "$BACKUP_DIR"/*.db 2>/dev/null || echo "Aucune sauvegarde trouv√©e"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        print_error "Fichier de sauvegarde non trouv√©: $backup_file"
        return 1
    fi
    
    local db_path
    db_path=$(find_database_path)
    
    print_step "Arr√™t du bot pour la restauration..."
    pm2 stop pcr 2>/dev/null || echo "Bot d√©j√† arr√™t√©"
    
    print_step "Restauration de la base de donn√©es..."
    cp "$backup_file" "$db_path"
    print_success "Base de donn√©es restaur√©e vers: $db_path"
    
    print_step "Red√©marrage du bot..."
    pm2 start "$PROJECT_DIR/index.js" --name pcr
    
    if check_app_status; then
        print_success "Base de donn√©es restaur√©e avec succ√®s"
    else
        print_error "Erreur lors de la restauration"
    fi
}

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

print_section() {
    echo -e "${CYAN}üìä $1${NC}"
    echo "----------------------------"
}

print_step() {
    echo -e "${GREEN}[√âTAPE]${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# Fonction pour v√©rifier si le bot est en ligne
check_app_status() {
    if pm2 list 2>/dev/null | grep -q "pcr.*online"; then
        return 0
    else
        return 1
    fi
}

# Fonction de monitoring compl√®te
monitor_function() {
    clear
    echo -e "${PURPLE}ü§ñ PCR BOT DISCORD - MONITORING${NC}"
    echo "================================="
    echo ""
    
    # 1. Statut PM2
    print_section "Statut PM2"
    if pm2 list 2>/dev/null | grep -q "pcr"; then
        pm2 list
        echo ""
        if check_app_status; then
            print_success "Bot PCR en ligne"
        else
            print_error "Bot PCR hors ligne"
        fi
    else
        print_error "Aucun processus PM2 trouv√©"
    fi
    echo ""

    # 2. Ressources syst√®me
    print_section "Ressources syst√®me"
    echo "üíæ M√©moire: $(free -h | awk '/^Mem:/ {printf "Utilis√©e: %s/%s (%.2f%%)", $3, $2, ($3/$2)*100}')"
    echo "üî• CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')% utilis√©"
    echo "üíø Disque: $(df -h / | awk 'NR==2 {printf "Utilis√©: %s/%s (%s)", $3, $2, $5}')"
    echo ""

    # 3. Informations de d√©ploiement
    print_section "Informations de d√©ploiement"
    echo "üìÅ R√©pertoire projet: $PROJECT_DIR"
    echo "üë§ Utilisateur: $(whoami)"
    echo "üñ•Ô∏è  Hostname: $(hostname)"
    echo "üìù Derni√®re modification: $(stat -c %y "$PROJECT_DIR/index.js" 2>/dev/null || stat -f %Sm "$PROJECT_DIR/index.js" 2>/dev/null || echo "Non disponible")"
    echo ""

    # 4. Logs r√©cents
    print_section "Logs r√©cents (derni√®res 5 lignes)"
    pm2 logs pcr --lines 5 --nostream 2>/dev/null || echo "Aucun log disponible"
    echo ""

    echo "üîÑ Pour actualiser: pcr monitor"
    echo "üìä Pour PM2 monitoring: pm2 monit"
    echo "üìã Pour red√©marrer: pcr restart"
}

# Fonction de mise √† jour
update_function() {
    cd "$PROJECT_DIR" || {
        print_error "Impossible d'acc√©der au r√©pertoire $PROJECT_DIR"
        exit 1
    }

    print_step "üîÑ Mise √† jour PCR Bot..."
    
    # Sauvegarde automatique avant mise √† jour
    print_step "Sauvegarde automatique avant mise √† jour..."
    backup_database || echo "Continuer sans sauvegarde..."

    # Sauvegarde des logs
    ensure_log_dir
    print_step "Sauvegarde des logs actuels..."
    if [ -f "$LOG_DIR/pcr.log" ]; then
        cp "$LOG_DIR/pcr.log" "$LOG_DIR/pcr.log.backup.$(date +%Y%m%d_%H%M%S)"
    fi

    # V√©rifier et arr√™ter PM2 si n√©cessaire
    print_step "üìã V√©rification du statut PM2..."
    if pm2 describe pcr &> /dev/null; then
        print_step "‚úÖ Processus PM2 'pcr' trouv√©"
        print_step "Arr√™t temporaire du bot..."
        pm2 stop pcr
    else
        print_warning "‚ö†Ô∏è Processus PM2 'pcr' non trouv√©"
    fi

    # Stash des changements locaux non commit√©s (si il y en a)
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_step "üíæ Sauvegarde des changements locaux..."
        git stash push -m "Auto-stash avant mise √† jour $(date)"
        stashed=true
    else
        stashed=false
    fi

    # Git pull
    print_step "R√©cup√©ration des derni√®res modifications..."
    git fetch origin
    git pull origin main || print_warning "Impossible de faire git pull"

    # V√©rifier si package.json a √©t√© modifi√©
    if git diff HEAD@{1} HEAD --name-only 2>/dev/null | grep -q "package.json"; then
        print_step "üì¶ package.json modifi√©, mise √† jour des d√©pendances..."
        npm install
    else
        print_step "Installation/mise √† jour des d√©pendances..."
        npm install
    fi

    # Restaurer les changements stash√©s si n√©cessaire
    if [ "$stashed" = true ]; then
        print_step "üîÑ Restauration des changements locaux sauvegard√©s..."
        git stash pop
    fi

    # Red√©marrage
    print_step "Red√©marrage du bot..."
    pm2 restart pcr || pm2 start index.js --name pcr
    pm2 save

    # V√©rification finale
    sleep 5
    if check_app_status; then
        print_success "üéâ Mise √† jour termin√©e avec succ√®s!"
        print_success "Le bot PCR est en ligne"
    else
        print_error "‚ùå Probl√®me lors de la mise √† jour"
        echo "V√©rifiez les logs avec: pcr logs"
    fi
}

# Fonction de cr√©ation de branche Git automatique
create_git_branch() {
    local branch_type="$1"  # "command" ou "event"
    local name="$2"
    local branch_name="feature/${branch_type}-${name}"
    
    # V√©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_warning "Pas dans un d√©p√¥t Git - ignorer la cr√©ation de branche"
        return 0
    fi
    
    # V√©rifier si on a des changements non committ√©s
    if ! git diff-index --quiet HEAD --; then
        print_warning "Changements non committ√©s d√©tect√©s"
        echo "Voulez-vous cr√©er un commit avant de cr√©er la nouvelle branche? (O/n): "
        read -n 1 stash_confirm
        echo ""
        if [[ "$stash_confirm" =~ ^[Oo]$ ]] || [[ -z "$stash_confirm" ]]; then
            git add -A
            git commit -m "Sauvegarde automatique avant cr√©ation de branche $branch_name"
            print_success "Changements sauvegard√©s"
        else
            print_warning "Cr√©ation de branche avec changements non committ√©s"
        fi
    fi
    
    # V√©rifier si la branche existe d√©j√†
    if git show-ref --verify --quiet refs/heads/"$branch_name"; then
        print_warning "La branche '$branch_name' existe d√©j√†"
        echo "Voulez-vous basculer sur cette branche? (O/n): "
        read -n 1 switch_confirm
        echo ""
        if [[ "$switch_confirm" =~ ^[Oo]$ ]] || [[ -z "$switch_confirm" ]]; then
            git checkout "$branch_name"
            print_success "Bascul√© sur la branche existante '$branch_name'"
        fi
        return 0
    fi
    
    # Cr√©er et basculer sur la nouvelle branche
    print_step "Cr√©ation de la branche Git '$branch_name'..."
    if git checkout -b "$branch_name"; then
        print_success "Branche '$branch_name' cr√©√©e et activ√©e"
        return 0
    else
        print_error "Erreur lors de la cr√©ation de la branche"
        return 1
    fi
}

# Fonction pour lister les branches de fonctionnalit√©s
list_feature_branches() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Pas dans un d√©p√¥t Git"
        return 1
    fi
    
    print_section "Branches de fonctionnalit√©s PCR"
    
    # Lister les branches feature/command-* et feature/event-*
    local feature_branches
    feature_branches=$(git branch | grep -E "(feature/command-|feature/event-)" | sed 's/^[* ] //')
    
    if [[ -z "$feature_branches" ]]; then
        print_warning "Aucune branche de fonctionnalit√© trouv√©e"
        echo ""
        echo "üí° Pour cr√©er une branche de fonctionnalit√©:"
        echo "  ‚Ä¢ pcr command --name <nom>    - Nouvelle commande"
        echo "  ‚Ä¢ pcr event --name <nom>      - Nouvel √©v√©nement"
        return 0
    fi
    
    echo "üåø Branches disponibles:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    local current_branch
    current_branch=$(git branch --show-current)
    
    while IFS= read -r branch; do
        local status_symbol=""
        local branch_info=""
        
        if [[ "$branch" == "$current_branch" ]]; then
            status_symbol="‚û§ "
            branch_info=" (COURANTE)"
        else
            status_symbol="  "
        fi
        
        # Extraire le type et le nom
        if [[ "$branch" =~ feature/command-(.+) ]]; then
            local cmd_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}üîß $branch${branch_info}"
            echo "    ‚îî‚îÄ Commande: $cmd_name"
        elif [[ "$branch" =~ feature/event-(.+) ]]; then
            local event_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}‚ö° $branch${branch_info}"
            echo "    ‚îî‚îÄ √âv√©nement: $event_name"
        else
            echo "${status_symbol}üåø $branch${branch_info}"
        fi
        echo ""
    done <<< "$feature_branches"
    
    echo "üí° Commandes utiles:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  ‚Ä¢ git checkout <branche>     - Basculer sur une branche"
    echo "  ‚Ä¢ git checkout main          - Revenir √† la branche principale"
    echo "  ‚Ä¢ git branch -d <branche>    - Supprimer une branche"
    echo "  ‚Ä¢ git push origin <branche>  - Pousser une branche"
}

# Fonction de commit automatique apr√®s cr√©ation
auto_commit_and_push() {
    local type="$1"      # "command" ou "event"
    local name="$2"
    local file_path="$3"
    local branch_name="feature/${type}-${name}"
    
    # V√©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        return 0
    fi
    
    print_step "Commit automatique du nouveau $type '$name'..."
    
    # Ajouter le fichier cr√©√©
    git add "$file_path"
    
    # Cr√©er le message de commit
    local commit_msg
    if [[ "$type" == "command" ]]; then
        commit_msg="feat: add new Discord command '$name'

- Generated using 'pcr command --name $name'
- File: $(basename "$file_path")
- Ready for implementation"
    else
        commit_msg="feat: add new Discord event '$name'

- Generated using 'pcr event --name $name' 
- File: $(basename "$file_path")
- Ready for implementation"
    fi
    
    # Effectuer le commit
    if git commit -m "$commit_msg"; then
        print_success "Commit effectu√© avec succ√®s"
        
        # Demander si on veut push
        echo ""
        echo "Voulez-vous pousser la branche vers le d√©p√¥t distant? (O/n): "
        read -n 1 push_confirm
        echo ""
        if [[ "$push_confirm" =~ ^[Oo]$ ]] || [[ -z "$push_confirm" ]]; then
            print_step "Push de la branche '$branch_name'..."
            if git push -u origin "$branch_name"; then
                print_success "Branche pouss√©e vers origin/$branch_name"
                echo ""
                echo "üåê Actions sugg√©r√©es:"
                echo "  ‚Ä¢ Cr√©er une Pull Request sur GitHub/GitLab"
                echo "  ‚Ä¢ Continuer le d√©veloppement sur cette branche"
                echo "  ‚Ä¢ Merger quand pr√™t: git checkout main && git merge $branch_name"
            else
                print_warning "Erreur lors du push - vous pouvez le faire manuellement plus tard"
                echo "  Commande: git push -u origin $branch_name"
            fi
        else
            print_success "Branche cr√©√©e localement (non pouss√©e)"
            echo ""
            echo "üí° Pour pousser plus tard:"
            echo "  git push -u origin $branch_name"
        fi
    else
        print_error "Erreur lors du commit"
        return 1
    fi
}

# Fonction de cr√©ation d'√©v√©nement
create_event() {
    local event_name="$1"
    
    if [[ -z "$event_name" ]]; then
        print_error "Nom d'√©v√©nement requis"
        echo "Usage: pcr event --name <nom_evenement>"
        echo "Exemple: pcr event --name messageUpdate"
        return 1
    fi
    
    # Cr√©er la branche Git automatiquement
    create_git_branch "event" "$event_name"
    
    # V√©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$event_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom d'√©v√©nement invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local events_dir="$PROJECT_DIR/events/client"
    local example_file="$events_dir/example"
    local new_event_file="$events_dir/$event_name.js"
    
    # V√©rifier si le fichier example existe
    if [[ ! -f "$example_file" ]]; then
        print_error "Fichier template non trouv√©: $example_file"
        return 1
    fi
    
    # V√©rifier si l'√©v√©nement existe d√©j√†
    if [[ -f "$new_event_file" ]]; then
        print_error "L'√©v√©nement '$event_name' existe d√©j√†"
        print_warning "Fichier existant: $new_event_file"
        return 1
    fi
    
    print_step "Cr√©ation de l'√©v√©nement '$event_name'..."
    
    # Copier le template et remplacer les valeurs par d√©faut
    cp "$example_file" "$new_event_file"
    
    # Remplacer 'name' par le nom de l'√©v√©nement
    sed -i "s/const name = 'name'/const name = '$event_name'/g" "$new_event_file"
    
    # Ajouter un commentaire d'identification
    sed -i "1i// √âv√©nement: $event_name" "$new_event_file"
    sed -i "2i//" "$new_event_file"
    
    print_success "√âv√©nement '$event_name' cr√©√© avec succ√®s!"
    print_success "Fichier: $new_event_file"
    
    # Commit automatique et push
    auto_commit_and_push "event" "$event_name" "$new_event_file"
    
    echo ""
    echo "üìù Prochaines √©tapes:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  1. √âditez le fichier pour personnaliser l'√©v√©nement"
    echo "  2. Modifiez la propri√©t√© 'once' (true/false)"
    echo "  3. Impl√©mentez la logique dans la fonction execute"
    echo "  4. Red√©marrez le bot: pcr restart"
    echo ""
    echo "üí° Commandes utiles:"
    echo "  ‚Ä¢ √âditer: nano $new_event_file"
    echo "  ‚Ä¢ Voir les logs: pcr logs"
    echo ""
    echo "üåø Git workflow:"
    echo "  ‚Ä¢ Branche courante: feature/event-$event_name"
    echo "  ‚Ä¢ Quand pr√™t: cr√©er une Pull Request"
    echo "  ‚Ä¢ Revenir √† main: git checkout main"
    echo ""
    echo "üìö √âv√©nements Discord courants:"
    echo "  ‚Ä¢ ready, messageCreate, messageDelete"
    echo "  ‚Ä¢ guildMemberAdd, guildMemberRemove"
    echo "  ‚Ä¢ interactionCreate, messageReactionAdd"
}

# Fonction de cr√©ation de commande
create_command() {
    local command_name="$1"
    local command_desc="$2"
    
    if [[ -z "$command_name" ]]; then
        print_error "Nom de commande requis"
        echo "Usage: pcr command --name <nom_commande> [--desc <description>]"
        echo "Exemple: pcr command --name hello"
        echo "Exemple: pcr command --name hello --desc \"Commande de salutation\""
        return 1
    fi
    
    # Cr√©er la branche Git automatiquement
    create_git_branch "command" "$command_name"
    
    # V√©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$command_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom de commande invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local commands_dir="$PROJECT_DIR/commands"
    local example_file="$commands_dir/example"
    local new_command_file="$commands_dir/$command_name.js"
    
    # V√©rifier si le fichier example existe
    if [[ ! -f "$example_file" ]]; then
        print_error "Fichier template non trouv√©: $example_file"
        return 1
    fi
    
    # V√©rifier si la commande existe d√©j√†
    if [[ -f "$new_command_file" ]]; then
        print_error "La commande '$command_name' existe d√©j√†"
        print_warning "Fichier existant: $new_command_file"
        return 1
    fi
    
    print_step "Cr√©ation de la commande '$command_name'..."
    
    # Copier le template et remplacer les valeurs par d√©faut
    cp "$example_file" "$new_command_file"
    
    # Remplacer 'name' par le nom de la commande
    sed -i "s/\.setName('name')/\.setName('$command_name')/g" "$new_command_file"
    
    # Remplacer 'Description' par une description personnalis√©e
    if [[ -n "$command_desc" ]]; then
        # Utiliser la description fournie
        sed -i "s/\.setDescription('Description')/\.setDescription('$command_desc')/g" "$new_command_file"
    else
        # Utiliser une description par d√©faut
        sed -i "s/\.setDescription('Description')/\.setDescription('Description de la commande $command_name')/g" "$new_command_file"
    fi
    
    print_success "Commande '$command_name' cr√©√©e avec succ√®s!"
    print_success "Fichier: $new_command_file"
    
    # Commit automatique et push
    auto_commit_and_push "command" "$command_name" "$new_command_file"
    
    echo ""
    echo "üìù Prochaines √©tapes:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  1. √âditez le fichier pour personnaliser la commande"
    echo "  2. Modifiez la description et les options"
    echo "  3. Impl√©mentez la logique dans la fonction execute"
    echo "  4. Red√©marrez le bot: pcr restart"
    echo ""
    echo "üí° Commandes utiles:"
    echo "  ‚Ä¢ √âditer: nano $new_command_file"
    echo "  ‚Ä¢ Voir les logs: pcr logs"
    echo ""
    echo "üåø Git workflow:"
    echo "  ‚Ä¢ Branche courante: feature/command-$command_name"
    echo "  ‚Ä¢ Quand pr√™t: cr√©er une Pull Request"
    echo "  ‚Ä¢ Revenir √† main: git checkout main"
}

# Fonction d'installation du script dans le PATH
install_script() {
    local script_path="/usr/local/bin/pcr"
    
    if [[ -f "$script_path" ]]; then
        echo -n "Le script est d√©j√† install√©. Voulez-vous le mettre √† jour? (O/n): "
        read -n 1 confirmation
        echo ""
        if [[ ! "$confirmation" =~ ^[Oo]$ ]] && [[ -n "$confirmation" ]]; then
            print_warning "Installation annul√©e"
            return 1
        fi
    fi
    
    print_step "Installation du script pcr dans /usr/local/bin..."
    
    # Copier le script
    if sudo cp "$PROJECT_DIR/pcr" "$script_path"; then
        sudo chmod +x "$script_path"
        print_success "Script install√© avec succ√®s!"
        print_success "Vous pouvez maintenant utiliser 'pcr' depuis n'importe o√π"
        echo ""
        echo "üí° Conseils:"
        echo "  - Utilisez 'pcr' depuis le r√©pertoire du projet ou ses sous-r√©pertoires"
        echo "  - Le script d√©tectera automatiquement le bon r√©pertoire de projet"
        echo "  - Pour d√©sinstaller: sudo rm /usr/local/bin/pcr"
    else
        print_error "Erreur lors de l'installation (permissions sudo requises)"
        return 1
    fi
}

case "$1" in
    dev)
        validate_project_directory
        echo "üöÄ Lancement du mode d√©veloppement..."
        echo ""
        print_step "D√©marrage du bot en mode d√©veloppement..."
        cd "$PROJECT_DIR"
        npm run dev
        ;;
    start)
        validate_project_directory
        print_section "D√©marrage du Bot PCR"
        cd "$PROJECT_DIR"
        pm2 start index.js --name pcr 2>/dev/null || {
            print_warning "Processus d√©j√† en cours, tentative de red√©marrage..."
            pm2 restart pcr
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "üéâ Bot PCR d√©marr√© avec succ√®s!"
            echo ""
            echo "üìä Informations du bot:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "ü§ñ Nom: PCR Discord Bot"
            echo "üìÅ R√©pertoire: $PROJECT_DIR"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ pcr status   - V√©rifier l'√©tat"
            echo "  ‚Ä¢ pcr logs     - Voir les logs"
            echo "  ‚Ä¢ pcr monitor  - Monitoring complet"
        else
            print_error "‚ùå √âchec du d√©marrage"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "  ‚Ä¢ V√©rifiez les logs: pcr logs"
            echo "  ‚Ä¢ V√©rifiez les permissions"
            echo "  ‚Ä¢ Red√©marrez: pcr restart"
        fi
        ;;
    stop)
        print_section "Arr√™t du Bot PCR"
        pm2 stop pcr 2>/dev/null || print_warning "Bot d√©j√† arr√™t√©"
        echo ""
        print_success "üõë Bot PCR arr√™t√© avec succ√®s"
        echo ""
        echo "üí° Pour red√©marrer:"
        echo "  ‚Ä¢ pcr start    - D√©marrer le bot"
        echo "  ‚Ä¢ pcr restart  - Red√©marrer directement"
        ;;
    restart)
        print_section "Red√©marrage du Bot PCR"
        cd "$PROJECT_DIR"
        pm2 restart pcr 2>/dev/null || {
            print_warning "Processus non trouv√©, d√©marrage..."
            pm2 start index.js --name pcr
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "üîÑ Bot PCR red√©marr√© avec succ√®s!"
            echo ""
            echo "üìä Informations du bot:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "ü§ñ Nom: PCR Discord Bot"
            echo "üìÅ R√©pertoire: $PROJECT_DIR"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ pcr logs     - Voir les logs"
            echo "  ‚Ä¢ pcr monitor  - Monitoring complet"
        else
            print_error "‚ùå √âchec du red√©marrage"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "  ‚Ä¢ V√©rifiez les logs: pcr logs"
            echo "  ‚Ä¢ Essayez un arr√™t/d√©marrage: pcr stop && pcr start"
        fi
        ;;
    status)
        print_section "Statut du Bot PCR"
        if check_app_status; then
            print_success "üü¢ Bot PCR en ligne"
            echo ""
            echo "üìä Informations rapides:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "ü§ñ Processus PM2: Actif"
            echo "üìÅ R√©pertoire: $PROJECT_DIR"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ pcr logs     - Voir les logs en temps r√©el"
            echo "  ‚Ä¢ pcr monitor  - Monitoring d√©taill√©"
        else
            print_error "üî¥ Bot PCR hors ligne"
            echo ""
            echo "üîç Actions sugg√©r√©es:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ pcr start    - D√©marrer le bot"
            echo "  ‚Ä¢ pcr logs     - V√©rifier les erreurs"
            echo "  ‚Ä¢ pcr deploy   - Red√©ployer si n√©cessaire"
        fi
        ;;
    logs)
        print_section "Logs du Bot PCR"
        echo "üìã Affichage en temps r√©el (Ctrl+C pour arr√™ter)"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        pm2 logs pcr 2>/dev/null || {
            print_error "Impossible d'acc√©der aux logs"
            echo ""
            echo "üîç V√©rifications:"
            echo "  ‚Ä¢ Le bot est-il d√©marr√©? pcr status"
            echo "  ‚Ä¢ Essayez de red√©marrer: pcr restart"
        }
        ;;
    monitor)
        monitor_function
        ;;
    update)
        update_function
        ;;
    deploy)
        echo "üöÄ D√©ploiement du bot PCR..."
        cd "$PROJECT_DIR"
        
        # Sauvegarde automatique avant d√©ploiement
        print_step "Sauvegarde automatique avant d√©ploiement..."
        backup_database || echo "Continuer sans sauvegarde..."
        
        # V√©rification et cr√©ation du fichier .env
        print_step "V√©rification de la configuration d'environnement..."
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env cr√©√© √† partir de .env.example"
                print_warning "N'oubliez pas de configurer vos tokens dans .env"
            else
                print_warning "Ni .env ni .env.example trouv√©s"
                print_warning "Assurez-vous d'avoir configur√© vos variables d'environnement"
            fi
        else
            print_success "Fichier .env d√©j√† pr√©sent"
        fi
        
        # Arr√™t de l'application
        print_step "Arr√™t du bot si il est en cours d'ex√©cution..."
        pm2 stop pcr 2>/dev/null || echo "Bot pas encore d√©marr√©"

        # Installation des d√©pendances
        print_step "Installation des d√©pendances..."
        npm install

        # D√©marrage du bot avec PM2
        print_step "D√©marrage du bot avec PM2..."
        pm2 start index.js --name pcr

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # V√©rification finale
        sleep 5
        if check_app_status; then
            print_success "üéâ D√©ploiement termin√© avec succ√®s!"
            print_success "Bot PCR Discord en ligne"
        else
            print_error "‚ùå Probl√®me lors du d√©ploiement"
        fi
        ;;
    event)
        # Gestion des options pour la commande event
        validate_project_directory
        
        # Parser les arguments
        event_name=""
        no_git=false
        
        # Analyser les param√®tres
        shift # Enlever 'event'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --name)
                    event_name="$2"
                    shift 2
                    ;;
                --no-git)
                    no_git=true
                    shift
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr event --name <nom_evenement> [--no-git]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$event_name" ]]; then
            if [[ "$no_git" == true ]]; then
                # Sauvegarder les fonctions Git temporairement
                create_git_branch() { return 0; }
                auto_commit_and_push() { return 0; }
            fi
            create_event "$event_name"
        else
            print_error "Usage: pcr event --name <nom_evenement> [--no-git]"
            echo "Exemple: pcr event --name messageUpdate"
            echo "Options:"
            echo "  --no-git    Skip Git branch creation and commit"
            echo ""
            echo "Cette commande cr√©e un nouvel √©v√©nement Discord en utilisant"
            echo "le template du fichier 'example' dans le dossier events/client/"
            echo ""
            echo "üìö √âv√©nements Discord courants:"
            echo "  ‚Ä¢ ready, messageCreate, messageDelete, messageUpdate"
            echo "  ‚Ä¢ guildMemberAdd, guildMemberRemove, guildMemberUpdate"
            echo "  ‚Ä¢ interactionCreate, messageReactionAdd, messageReactionRemove"
        fi
        ;;
    command)
        # Gestion des options pour la commande command
        validate_project_directory
        
        # Parser les arguments
        command_name=""
        command_desc=""
        no_git=false
        
        # Analyser les param√®tres
        shift # Enlever 'command'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --name)
                    command_name="$2"
                    shift 2
                    ;;
                --desc)
                    command_desc="$2"
                    shift 2
                    ;;
                --no-git)
                    no_git=true
                    shift
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr command --name <nom_commande> [--desc <description>] [--no-git]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$command_name" ]]; then
            if [[ "$no_git" == true ]]; then
                # Sauvegarder les fonctions Git temporairement
                create_git_branch() { return 0; }
                auto_commit_and_push() { return 0; }
            fi
            create_command "$command_name" "$command_desc"
        else
            print_error "Usage: pcr command --name <nom_commande> [--desc <description>] [--no-git]"
            echo "Exemple: pcr command --name hello"
            echo "Exemple: pcr command --name hello --desc \"Commande de salutation\""
            echo "Options:"
            echo "  --no-git    Skip Git branch creation and commit"
            echo ""
            echo "Cette commande cr√©e une nouvelle commande Discord en utilisant"
            echo "le template du fichier 'example' dans le dossier commands/"
        fi
        ;;
    branches)
        validate_project_directory
        list_feature_branches
        ;;
    install)
        install_script
        ;;
    backup)
        validate_project_directory
        print_section "Sauvegarde de la Base de Donn√©es"
        if backup_database; then
            echo ""
            echo "üí° Commandes utiles:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ pcr restore <fichier>  - Restaurer une sauvegarde"
            echo "  ‚Ä¢ ls -la $BACKUP_DIR     - Voir toutes les sauvegardes"
        else
            echo ""
            echo "üîç V√©rifications:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ La base de donn√©es existe-t-elle?"
            echo "  ‚Ä¢ Le bot a-t-il √©t√© initialis√©? pcr deploy"
        fi
        ;;
    restore)
        validate_project_directory
        if [[ -n "$2" ]]; then
            print_section "Restauration de la Base de Donn√©es"
            restore_database "$2"
        else
            print_section "Sauvegardes Disponibles"
            if ls "$BACKUP_DIR"/*.db 1> /dev/null 2>&1; then
                ls -la "$BACKUP_DIR"/*.db
                echo ""
                echo "Usage: pcr restore <fichier_backup>"
                echo "Exemple:"
                echo "  pcr restore $BACKUP_DIR/$(ls "$BACKUP_DIR"/*.db 2>/dev/null | head -1 | xargs basename)"
            else
                print_warning "Aucune sauvegarde trouv√©e"
                echo ""
                echo "üí° Pour cr√©er une sauvegarde:"
                echo "  pcr backup"
            fi
        fi
        ;;
    reset)
        # V√©rifier si l'option --y ou -y est pr√©sente
        auto_confirm=false
        if [[ "$2" == "--y" ]] || [[ "$2" == "-y" ]]; then
            auto_confirm=true
        fi
        
        echo "üîÑ R√©initialisation compl√®te du bot PCR..."
        echo ""
        echo -e "${YELLOW}‚ö†Ô∏è  ATTENTION: Cette action va supprimer toutes les donn√©es!${NC}"
        echo -e "${YELLOW}‚ö†Ô∏è  Les messages, configurations et donn√©es du bot seront perdues!${NC}"
        echo ""
        
        # Sauvegarde de s√©curit√© avant reset
        if [[ "$auto_confirm" != true ]]; then
            echo "üíæ Cr√©ation d'une sauvegarde de s√©curit√© avant reset..."
            backup_database || echo "Continuer sans sauvegarde..."
            echo ""
        fi
        
        if [ "$auto_confirm" = true ]; then
            echo "Mode automatique activ√© (--y), confirmation ignor√©e"
            confirmation="o"
        else
            echo -n "√ätes-vous s√ªr de vouloir continuer? (O/n): "
            read -n 1 confirmation
            echo ""
        fi
        
        if [[ "$confirmation" =~ ^[Oo]$ ]] || [ -z "$confirmation" ]; then
            cd "$PROJECT_DIR" || {
                print_error "Impossible d'acc√©der au r√©pertoire $PROJECT_DIR"
                exit 1
            }

            # Suppression des logs
            print_step "Suppression des logs..."
            if [ -d "$LOG_DIR" ]; then
                rm -rf "$LOG_DIR"/*
                print_success "Logs supprim√©s et r√©pertoire recr√©√©"
            else
                mkdir -p "$LOG_DIR"
            fi

            # Suppression de la base de donn√©es
            print_step "Suppression de la base de donn√©es..."
            db_path=$(find_database_path)
            if [[ -f "$db_path" ]]; then
                rm -f "$db_path"
                print_success "Base de donn√©es supprim√©e"
            fi

            # Arr√™t et suppression du processus PM2
            print_step "Arr√™t du processus PM2..."
            pm2 stop pcr 2>/dev/null || echo "Processus d√©j√† arr√™t√©"
            pm2 delete pcr 2>/dev/null || echo "Processus non trouv√©"

            # R√©installation des d√©pendances
            print_step "R√©installation des d√©pendances..."
            rm -rf node_modules package-lock.json
            npm install

            # Red√©marrage
            print_step "Red√©marrage du bot..."
            pm2 start index.js --name pcr
            pm2 save
            
            sleep 2
            if check_app_status; then
                print_success "üéâ R√©initialisation termin√©e avec succ√®s!"
                print_success "Bot PCR red√©marr√© avec une configuration propre"
            else
                print_error "‚ùå Erreur lors de la r√©initialisation"
            fi
        else
            print_warning "R√©initialisation annul√©e"
        fi
        ;;
    *)
        echo -e "${PURPLE}ü§ñ PCR BOT DISCORD - Script de gestion unifi√©${NC}"
        echo "============================================="
        echo ""
        echo "Usage: pcr [commande]"
        echo ""
        echo "Commandes disponibles:"
        echo ""
        echo "üöÄ Gestion du bot:"
        echo "  start         - D√©marre le bot"
        echo "  stop          - Arr√™te le bot"
        echo "  restart       - Red√©marre le bot"
        echo "  status        - Affiche le statut du bot"
        echo ""
        echo "üìä Monitoring et logs:"
        echo "  logs          - Affiche les logs PM2 du bot en temps r√©el"
        echo "  monitor       - Monitoring complet avec ressources syst√®me"
        echo ""
        echo "üîß D√©veloppement:"
        echo "  dev           - Lance le bot en mode d√©veloppement (avec nodemon)"
        echo "  command       - Cr√©e une nouvelle commande Discord avec branche Git"
        echo "                  Usage: pcr command --name <nom> [--desc <description>] [--no-git]"
        echo "  event         - Cr√©e un nouvel √©v√©nement Discord avec branche Git"
        echo "                  Usage: pcr event --name <nom> [--no-git]"
        echo "  branches      - Liste les branches de fonctionnalit√©s PCR"
        echo ""
        echo "üöÄ D√©ploiement:"
        echo "  deploy        - D√©ploiement complet du bot"
        echo "  update        - Mise √† jour du bot depuis Git"
        echo ""
        echo "üíæ Sauvegarde et restauration:"
        echo "  backup        - Sauvegarde la base de donn√©es"
        echo "  restore       - Restaure une sauvegarde (pcr restore <fichier>)"
        echo ""
        echo "‚öôÔ∏è Configuration:"
        echo "  install       - Installe le script dans le PATH global"
        echo "  reset         - R√©initialise compl√®tement le bot (‚ö†Ô∏è SUPPRIME TOUTES LES DONN√âES)"
        echo "                  Options: --y ou -y pour confirmer automatiquement"
        echo ""
        echo "Architecture:"
        echo "  üìÅ Bot Discord : PCR - Gestion communautaire"
        echo "  üìÅ Base de donn√©es : SQLite (messages.db)"
        echo "  üìÅ Logs : PM2 + fichiers locaux"
        echo ""
        exit 1
        ;;
esac

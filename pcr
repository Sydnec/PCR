#!/bin/bash

# Configuration
APP_NAME="PCR"
MAIN_FILE="index.js"
REPO_URL="https://github.com/Sydnec/PCR.git"

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Fonction d'aide
show_help() {
    echo -e "${BLUE}Usage: pcr [command] [options]${NC}"
    echo ""
    echo "Lifecycle (PM2):"
    echo "  start       Démarrer le bot via PM2"
    echo "  stop        Arrêter le bot"
    echo "  restart     Redémarrer le bot"
    echo "  status      Voir le statut PM2"
    echo "  logs        Voir les logs PM2"
    echo "  monitor     Ouvrir le moniteur PM2"
    echo "  deploy      Install dependencies + Start/Reload PM2 (CI/CD friendly)"
    echo "  update      Git pull + deploy"
    echo "  install     Installer ce script dans le PATH système"
    echo ""
    echo "Development:"
    echo "  feature <type> <name>   Créer une branche et un fichier depuis l'exemple"
    echo "                          Types: command, event, handler"
    echo "  finish                  Merger la branche courante dans main et supprimer la branche"
    echo "  release <type>          Créer une nouvelle version (major, minor, fix/patch)"
    echo ""
}

# Commandes
case "$1" in
    start)
        echo -e "${GREEN}Démarrage de $APP_NAME avec PM2...${NC}"
        pm2 start "$MAIN_FILE" --name "$APP_NAME"
        ;;

    stop)
        echo -e "${YELLOW}Arrêt de $APP_NAME...${NC}"
        pm2 stop "$APP_NAME"
        ;;

    restart)
        echo -e "${YELLOW}Redémarrage de $APP_NAME...${NC}"
        pm2 restart "$APP_NAME"
        ;;

    status)
        pm2 status "$APP_NAME"
        ;;

    logs)
        pm2 logs "$APP_NAME"
        ;;

    monitor)
        pm2 monit
        ;;

    deploy)
        echo -e "${BLUE}Installation des dépendances...${NC}"
        npm install
        
        echo -e "${BLUE}Vérification de PM2...${NC}"
        if pm2 describe "$APP_NAME" > /dev/null 2>&1; then
            echo -e "${GREEN}Application existante détectée. Rechargement...${NC}"
            pm2 reload "$APP_NAME" --update-env
        else
            echo -e "${GREEN}Premier lancement de l'application...${NC}"
            pm2 start "$MAIN_FILE" --name "$APP_NAME"
        fi
        
        echo -e "${BLUE}Sauvegarde de la liste des processus PM2...${NC}"
        pm2 save
        echo -e "${GREEN}Déploiement terminé.${NC}"
        ;;

    backup)
        BACKUP_DIR="backups"
        DATE=$(date +%Y%m%d_%H%M%S)
        FILENAME="backup_${APP_NAME}_${DATE}.tar.gz"
        
        mkdir -p "$BACKUP_DIR"
        echo -e "${BLUE}Création de la sauvegarde $FILENAME...${NC}"
        
        # Exclure node_modules, .git, backups et les logs
        tar -czf "$BACKUP_DIR/$FILENAME" \
            --exclude="node_modules" \
            --exclude=".git" \
            --exclude="$BACKUP_DIR" \
            --exclude="*.log" \
            .
            
        echo -e "${GREEN}Sauvegarde terminée : $BACKUP_DIR/$FILENAME${NC}"
        # Garder seulement les 5 dernières sauvegardes
        ls -t "$BACKUP_DIR"/backup_*.tar.gz | tail -n +6 | xargs -r rm
        ;;

    update)
        echo -e "${BLUE}Mise à jour depuis git...${NC}"
        git pull
        $0 deploy
        echo -e "${GREEN}Mise à jour terminée.${NC}"
        ;;

    install)
        SCRIPT_PATH=$(readlink -f "$0")
        echo -e "${BLUE}Installation du script pcr dans /usr/local/bin...${NC}"
        if [ -w /usr/local/bin ]; then
            ln -sf "$SCRIPT_PATH" /usr/local/bin/pcr
        else
            echo -e "${YELLOW}Permission refusée. Tentative avec sudo...${NC}"
            sudo ln -sf "$SCRIPT_PATH" /usr/local/bin/pcr
        fi
        chmod +x "$SCRIPT_PATH"
        echo -e "${GREEN}Installé ! Vous pouvez maintenant taper 'pcr' n'importe où.${NC}"
        ;;

    feature)
        TYPE=$2
        NAME=$3
        
        if [ -z "$TYPE" ] || [ -z "$NAME" ]; then
            echo -e "${RED}Erreur: Arguments manquants.${NC}"
            echo "Usage: pcr feature <command|event|handler> <name>"
            exit 1
        fi

        # Création de la branche
        BRANCH_NAME="feature/$NAME"
        echo -e "${BLUE}Création de la branche $BRANCH_NAME...${NC}"
        git checkout -b "$BRANCH_NAME"

        # Copie des fichiers exemples
        case "$TYPE" in
            command)
                cp "commands/example" "commands/$NAME.js"
                echo -e "${GREEN}Fichier créé: commands/$NAME.js${NC}"
                ;;
            event)
                cp "events/client/example" "events/client/$NAME.js"
                echo -e "${GREEN}Fichier créé: events/client/$NAME.js${NC}"
                ;;
            handler)
                cp "functions/handlers/example" "functions/handlers/$NAME.js"
                echo -e "${GREEN}Fichier créé: functions/handlers/$NAME.js${NC}"
                ;;
            *)
                echo -e "${RED}Type inconnu: $TYPE. Utilisez command, event ou handler.${NC}"
                ;;
        esac
        ;;

    finish)
        CURRENT_BRANCH=$(git branch --show-current)
        if [ "$CURRENT_BRANCH" == "main" ] || [ "$CURRENT_BRANCH" == "master" ]; then
            echo -e "${RED}Vous êtes déjà sur la branche principale.${NC}"
            exit 1
        fi

        echo -e "${BLUE}Finalisation de la feature $CURRENT_BRANCH...${NC}"
        git checkout main || git checkout master
        git pull
        git merge "$CURRENT_BRANCH"
        
        read -p "Voulez-vous supprimer la branche locale $CURRENT_BRANCH ? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            git branch -d "$CURRENT_BRANCH"
        fi
        echo -e "${GREEN}Feature terminée et mergée !${NC}"
        ;;

    release)
        RELEASE_TYPE=$2 # major, minor, or patch (fix)
        if [[ "$RELEASE_TYPE" == "fix" ]]; then RELEASE_TYPE="patch"; fi

        if [[ ! "$RELEASE_TYPE" =~ ^(major|minor|patch)$ ]]; then
            echo -e "${RED}Type de release invalide. Utilisez: major, minor, ou fix (patch)${NC}"
            exit 1
        fi

        # Vérifier que le repo est propre
        if [ -n "$(git status --porcelain)" ]; then
            echo -e "${RED}Le répertoire de travail n'est pas propre. Veuillez commit ou stash vos changements.${NC}"
            exit 1
        fi

        echo -e "${BLUE}Préparation de la release $RELEASE_TYPE...${NC}"

        # 1. Bump version npm (sans git tag pour l'instant pour pouvoir modifier le changelog)
        NEW_VERSION=$(npm version $RELEASE_TYPE --no-git-tag-version)
        VERSION_NUM=${NEW_VERSION#v} # Enlever le 'v'

        echo -e "${BLUE}Nouvelle version: $VERSION_NUM${NC}"

        # 2. Mise à jour du changelog.json via Node
        node -e "
        const fs = require('fs');
        const path = './changelog.json';
        const changelog = require(path);
        
        const newRelease = {
            version: '$VERSION_NUM',
            date: new Date().toISOString().split('T')[0],
            title: 'Release $VERSION_NUM',
            features: []
        };
        
        changelog.version = '$VERSION_NUM';
        changelog.lastUpdated = new Date().toISOString();
        changelog.releases.unshift(newRelease);
        
        fs.writeFileSync(path, JSON.stringify(changelog, null, 2));
        console.log('Changelog mis à jour.');
        "

        # 3. Commit et Tag
        echo -e "${BLUE}Commit et Tag...${NC}"
        git add package.json package-lock.json changelog.json
        git commit -m "chore(release): version $VERSION_NUM"
        git tag -a "$NEW_VERSION" -m "Release $VERSION_NUM"

        # 4. Push
        echo -e "${BLUE}Push vers le remote...${NC}"
        git push origin main --follow-tags

        echo -e "${GREEN}Release $VERSION_NUM déployée avec succès !${NC}"
        ;;

    help|*)
        show_help
        ;;
esac

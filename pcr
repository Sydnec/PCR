#!/bin/bash

# ü§ñ PCR Bot Discord - Script de gestion unifi√©
# Usage: pcr [command]

# Auto-d√©tection du r√©pertoire du projet
# Si le script est dans /usr/local/bin, on utilise le r√©pertoire courant
# Sinon, on utilise le r√©pertoire du script

if [[ "$(realpath "$0")" == "/usr/local/bin/pcr" ]]; then
    # Script install√© globalement, utiliser le r√©pertoire courant
    PROJECT_DIR="$(pwd)"
    # V√©rifier si on est dans un projet PCR valide
    if [[ ! -f "index.js" ]] || [[ ! -f "package.json" ]]; then
        # Essayer de trouver le projet dans les r√©pertoires parents
        current_dir="$(pwd)"
        found=false
        while [[ "$current_dir" != "/" ]]; do
            if [[ -f "$current_dir/index.js" ]] && [[ -f "$current_dir/package.json" ]] && [[ -f "$current_dir/pcr" ]]; then
                PROJECT_DIR="$current_dir"
                found=true
                break
            fi
            current_dir="$(dirname "$current_dir")"
        done
        
        if [[ "$found" != true ]]; then
            PROJECT_DIR="/home/sydnec/PCR"  # Fallback
        fi
    fi
else
    # Script local, utiliser le r√©pertoire du script
    PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

LOG_DIR="$PROJECT_DIR/logs"
BACKUP_DIR="$PROJECT_DIR/backups"

# Validation du r√©pertoire de projet
validate_project_directory() {
    if [[ ! -f "$PROJECT_DIR/index.js" ]] || [[ ! -f "$PROJECT_DIR/package.json" ]]; then
        print_error "Ce r√©pertoire ne semble pas √™tre un projet PCR valide."
        print_error "Fichiers attendus :"
        print_error "  - index.js: $PROJECT_DIR/index.js"
        print_error "  - package.json: $PROJECT_DIR/package.json"
        print_error ""
        print_error "R√©pertoire actuel d√©tect√© : $PROJECT_DIR"
        print_error "Assurez-vous d'√™tre dans le r√©pertoire racine du projet ou que les fichiers existent."
        exit 1
    fi
}

# Cr√©ation du r√©pertoire de backup si n√©cessaire
ensure_backup_dir() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
}

# Cr√©ation du r√©pertoire de logs si n√©cessaire
ensure_log_dir() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
    fi
}

# Fonction pour trouver le chemin de la base de donn√©es
find_database_path() {
    local db_paths=(
        "$PROJECT_DIR/messages.db"
        "$PROJECT_DIR/database.db"
        "$PROJECT_DIR/bot.db"
    )
    
    for path in "${db_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Retourner le chemin standard si aucun fichier trouv√©
    echo "$PROJECT_DIR/messages.db"
    return 1
}

# Fonction de sauvegarde de la base de donn√©es
backup_database() {
    ensure_backup_dir
    local backup_file="$BACKUP_DIR/db_backup_$(date +%Y%m%d_%H%M%S).db"
    local db_path
    
    db_path=$(find_database_path)
    
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "$backup_file"
        print_success "Base de donn√©es sauvegard√©e : $backup_file"
        print_success "Source: $db_path"
        return 0
    else
        print_warning "Aucune base de donn√©es trouv√©e"
        print_warning "Emplacements v√©rifi√©s:"
        print_warning "  - $PROJECT_DIR/messages.db"
        print_warning "  - $PROJECT_DIR/database.db"
        print_warning "  - $PROJECT_DIR/bot.db"
        return 1
    fi
}

# Fonction de restauration de la base de donn√©es
restore_database() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        print_error "Fichier de sauvegarde requis"
        echo "Usage: pcr restore <fichier_backup>"
        echo "Sauvegardes disponibles:"
        ls -la "$BACKUP_DIR"/*.db 2>/dev/null || echo "Aucune sauvegarde trouv√©e"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        print_error "Fichier de sauvegarde non trouv√©: $backup_file"
        return 1
    fi
    
    local db_path
    db_path=$(find_database_path)
    
    print_step "Arr√™t du bot pour la restauration..."
    pm2 stop pcr 2>/dev/null || echo "Bot d√©j√† arr√™t√©"
    
    print_step "Restauration de la base de donn√©es..."
    cp "$backup_file" "$db_path"
    print_success "Base de donn√©es restaur√©e vers: $db_path"
    
    print_step "Red√©marrage du bot..."
    pm2 start "$PROJECT_DIR/index.js" --name pcr
    
    if check_app_status; then
        print_success "Base de donn√©es restaur√©e avec succ√®s"
    else
        print_error "Erreur lors de la restauration"
    fi
}

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

print_section() {
    echo -e "${CYAN}üìä $1${NC}"
    echo "----------------------------"
}

print_step() {
    echo -e "${GREEN}[√âTAPE]${NC} $1"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

print_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

# Fonction pour v√©rifier si le bot est en ligne
check_app_status() {
    if pm2 list 2>/dev/null | grep -q "pcr.*online"; then
        return 0
    else
        return 1
    fi
}

# Fonction de monitoring compl√®te
monitor_function() {
    clear
    echo -e "${PURPLE}ü§ñ PCR BOT DISCORD - MONITORING${NC}"
    echo "================================="
    echo ""
    
    # 1. Statut PM2
    print_section "Statut PM2"
    if pm2 list 2>/dev/null | grep -q "pcr"; then
        pm2 list
        echo ""
        if check_app_status; then
            print_success "Bot PCR en ligne"
        else
            print_error "Bot PCR hors ligne"
        fi
    else
        print_error "Aucun processus PM2 trouv√©"
    fi
    echo ""

    # 2. Ressources syst√®me
    print_section "Ressources syst√®me"
    echo "üíæ M√©moire: $(free -h | awk '/^Mem:/ {printf "Utilis√©e: %s/%s (%.2f%%)", $3, $2, ($3/$2)*100}')"
    echo "üî• CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')% utilis√©"
    echo "üíø Disque: $(df -h / | awk 'NR==2 {printf "Utilis√©: %s/%s (%s)", $3, $2, $5}')"
    echo ""

    # 3. Informations de d√©ploiement
    print_section "Informations de d√©ploiement"
    echo "üìÅ R√©pertoire projet: $PROJECT_DIR"
    echo "üë§ Utilisateur: $(whoami)"
    echo "üñ•Ô∏è  Hostname: $(hostname)"
    echo "üìù Derni√®re modification: $(stat -c %y "$PROJECT_DIR/index.js" 2>/dev/null || stat -f %Sm "$PROJECT_DIR/index.js" 2>/dev/null || echo "Non disponible")"
    echo ""

    # 4. Logs r√©cents
    print_section "Logs r√©cents (derni√®res 5 lignes)"
    pm2 logs pcr --lines 5 --nostream 2>/dev/null || echo "Aucun log disponible"
    echo ""

    echo "üîÑ Pour actualiser: pcr monitor"
    echo "üìä Pour PM2 monitoring: pm2 monit"
    echo "üìã Pour red√©marrer: pcr restart"
}

# Fonction de mise √† jour
update_function() {
    cd "$PROJECT_DIR" || {
        print_error "Impossible d'acc√©der au r√©pertoire $PROJECT_DIR"
        exit 1
    }

    print_step "üîÑ Mise √† jour PCR Bot..."
    
    # Sauvegarde automatique avant mise √† jour
    print_step "Sauvegarde automatique avant mise √† jour..."
    backup_database || echo "Continuer sans sauvegarde..."

    # Sauvegarde des logs
    ensure_log_dir
    print_step "Sauvegarde des logs actuels..."
    if [ -f "$LOG_DIR/pcr.log" ]; then
        cp "$LOG_DIR/pcr.log" "$LOG_DIR/pcr.log.backup.$(date +%Y%m%d_%H%M%S)"
    fi

    # V√©rifier et arr√™ter PM2 si n√©cessaire
    print_step "üìã V√©rification du statut PM2..."
    if pm2 describe pcr &> /dev/null; then
        print_step "‚úÖ Processus PM2 'pcr' trouv√©"
        print_step "Arr√™t temporaire du bot..."
        pm2 stop pcr
    else
        print_warning "‚ö†Ô∏è Processus PM2 'pcr' non trouv√©"
    fi

    # Stash des changements locaux non commit√©s (si il y en a)
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_step "üíæ Sauvegarde des changements locaux..."
        git stash push -m "Auto-stash avant mise √† jour $(date)"
        stashed=true
    else
        stashed=false
    fi

    # Git pull
    print_step "R√©cup√©ration des derni√®res modifications..."
    git fetch origin
    git pull origin main || print_warning "Impossible de faire git pull"

    # V√©rifier si package.json a √©t√© modifi√©
    if git diff HEAD@{1} HEAD --name-only 2>/dev/null | grep -q "package.json"; then
        print_step "üì¶ package.json modifi√©, mise √† jour des d√©pendances..."
        npm install
    else
        print_step "Installation/mise √† jour des d√©pendances..."
        npm install
    fi

    # Restaurer les changements stash√©s si n√©cessaire
    if [ "$stashed" = true ]; then
        print_step "üîÑ Restauration des changements locaux sauvegard√©s..."
        git stash pop
    fi

    # Red√©marrage
    print_step "Red√©marrage du bot..."
    pm2 restart pcr || pm2 start index.js --name pcr
    pm2 save

    # V√©rification finale
    sleep 5
    if check_app_status; then
        print_success "üéâ Mise √† jour termin√©e avec succ√®s!"
        print_success "Le bot PCR est en ligne"
    else
        print_error "‚ùå Probl√®me lors de la mise √† jour"
        echo "V√©rifiez les logs avec: pcr logs"
    fi
}

# Fonction de cr√©ation de branche Git automatique
create_git_branch() {
    local branch_type="$1"  # "command" ou "event"
    local name="$2"
    local branch_name="feature/${branch_type}-${name}"
    
    # V√©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_warning "Pas dans un d√©p√¥t Git - ignorer la cr√©ation de branche"
        return 0
    fi
    
    # V√©rifier si on a des changements non committ√©s
    if ! git diff-index --quiet HEAD --; then
        print_warning "Changements non committ√©s d√©tect√©s"
        echo "Voulez-vous cr√©er un commit avant de cr√©er la nouvelle branche? (O/n): "
        read -n 1 stash_confirm
        echo ""
        if [[ "$stash_confirm" =~ ^[Oo]$ ]] || [[ -z "$stash_confirm" ]]; then
            git add -A
            git commit -m "Sauvegarde automatique avant cr√©ation de branche $branch_name"
            print_success "Changements sauvegard√©s"
        else
            print_warning "Cr√©ation de branche avec changements non committ√©s"
        fi
    fi
    
    # V√©rifier si la branche existe d√©j√†
    if git show-ref --verify --quiet refs/heads/"$branch_name"; then
        print_warning "La branche '$branch_name' existe d√©j√†"
        echo "Voulez-vous basculer sur cette branche? (O/n): "
        read -n 1 switch_confirm
        echo ""
        if [[ "$switch_confirm" =~ ^[Oo]$ ]] || [[ -z "$switch_confirm" ]]; then
            git checkout "$branch_name"
            print_success "Bascul√© sur la branche existante '$branch_name'"
        fi
        return 0
    fi
    
    # Cr√©er et basculer sur la nouvelle branche
    print_step "Cr√©ation de la branche Git '$branch_name'..."
    if git checkout -b "$branch_name"; then
        print_success "Branche '$branch_name' cr√©√©e et activ√©e"
        return 0
    else
        print_error "Erreur lors de la cr√©ation de la branche"
        return 1
    fi
}

# Fonction pour lister les branches de fonctionnalit√©s
list_feature_branches() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Pas dans un d√©p√¥t Git"
        return 1
    fi
    
    print_section "Branches de fonctionnalit√©s PCR"
    
    # Lister les branches feature/command-* et feature/event-*
    local feature_branches
    feature_branches=$(git branch | grep -E "(feature/command-|feature/event-)" | sed 's/^[* ] //')
    
    if [[ -z "$feature_branches" ]]; then
        print_warning "Aucune branche de fonctionnalit√© trouv√©e"
        echo ""
        echo "üí° Pour cr√©er une branche de fonctionnalit√©:"
        echo "  ‚Ä¢ pcr command --name <nom>    - Nouvelle commande"
        echo "  ‚Ä¢ pcr event --name <nom>      - Nouvel √©v√©nement"
        return 0
    fi
    
    echo "üåø Branches disponibles:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    
    local current_branch
    current_branch=$(git branch --show-current)
    
    while IFS= read -r branch; do
        local status_symbol=""
        local branch_info=""
        
        if [[ "$branch" == "$current_branch" ]]; then
            status_symbol="‚û§ "
            branch_info=" (COURANTE)"
        else
            status_symbol="  "
        fi
        
        # Extraire le type et le nom
        if [[ "$branch" =~ feature/command-(.+) ]]; then
            local cmd_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}üîß $branch${branch_info}"
            echo "    ‚îî‚îÄ Commande: $cmd_name"
        elif [[ "$branch" =~ feature/event-(.+) ]]; then
            local event_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}‚ö° $branch${branch_info}"
            echo "    ‚îî‚îÄ √âv√©nement: $event_name"
        else
            echo "${status_symbol}üåø $branch${branch_info}"
        fi
        echo ""
    done <<< "$feature_branches"
    
    echo "üí° Commandes utiles:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  ‚Ä¢ git checkout <branche>     - Basculer sur une branche"
    echo "  ‚Ä¢ git checkout main          - Revenir √† la branche principale"
    echo "  ‚Ä¢ git branch -d <branche>    - Supprimer une branche"
    echo "  ‚Ä¢ git push origin <branche>  - Pousser une branche"
}

# ===== SYST√àME DE CHANGELOG ET RELEASE =====

# Fonction pour obtenir la version du projet depuis package.json
get_project_version() {
    if [[ -f "$PROJECT_DIR/package.json" ]]; then
        grep '"version"' "$PROJECT_DIR/package.json" | sed 's/.*"version": *"\([^"]*\)".*/\1/'
    else
        echo "1.0.0"
    fi
}

# Fonction pour ajouter une feature au changelog pending
add_pending_feature() {
    local type="$1"
    local name="$2"
    local description="$3"
    
    print_step "Ajout de la feature au changelog..."
    
    # Cr√©er le script Node.js temporaire
    local temp_script="/tmp/pcr_add_feature_$$"
    cat > "$temp_script.js" << EOF
import { addPendingFeature } from '${PROJECT_DIR}/modules/version-manager.js';

try {
    const feature = addPendingFeature({
        type: '${type}',
        name: '${name}',
        description: '${description}'
    });
    
    if (feature) {
        console.log('‚úÖ Feature ajout√©e au changelog');
    }
} catch (error) {
    console.error('‚ùå Erreur:', error.message);
    process.exit(1);
}
EOF

    cd "$PROJECT_DIR"
    if node "$temp_script.js"; then
        rm -f "$temp_script.js"
        return 0
    else
        rm -f "$temp_script.js"
        print_warning "Impossible d'ajouter la feature au changelog"
        return 1
    fi
}

# Fonction pour cr√©er une release
create_release() {
    local version_type="$1"  # patch, minor, major
    local title="$2"
    
    print_section "Cr√©ation d'une nouvelle release"
    
    # V√©rifier qu'on est sur main
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
    
    if [[ "$current_branch" != "main" ]] && [[ "$current_branch" != "master" ]]; then
        echo "‚ö†Ô∏è  Vous n'√™tes pas sur la branche principale (main/master)"
        echo "Branche actuelle: $current_branch"
        echo ""
        echo "Voulez-vous continuer quand m√™me? (o/N): "
        read -n 1 continue_confirm
        echo ""
        if [[ ! "$continue_confirm" =~ ^[Oo]$ ]]; then
            print_warning "Release annul√©e"
            return 1
        fi
    fi
    
    # Cr√©er le script Node.js temporaire
    local temp_script="/tmp/pcr_release_$$"
    cat > "$temp_script.js" << EOF
import { createRelease, getChangelogStats, generateChangelogMarkdown } from '${PROJECT_DIR}/modules/version-manager.js';
import fs from 'fs';

try {
    // V√©rifier les features pending
    const stats = getChangelogStats();
    console.log(\`üìä Features en attente: \${stats.pendingFeatures}\`);
    
    if (stats.pendingFeatures === 0) {
        console.log('‚ö†Ô∏è  Aucune feature en attente pour la release');
        process.exit(1);
    }
    
    // Cr√©er la release
    const release = createRelease('${version_type}', '${title}');
    
    // G√©n√©rer le changelog markdown
    const markdown = generateChangelogMarkdown();
    fs.writeFileSync('CHANGELOG.md', markdown);
    
    console.log(\`üéâ Release \${release.version} cr√©√©e avec succ√®s!\`);
    console.log(\`üìã Features incluses: \${release.features.length}\`);
    console.log('üìù CHANGELOG.md g√©n√©r√©');
    
} catch (error) {
    console.error('‚ùå Erreur:', error.message);
    process.exit(1);
}
EOF

    cd "$PROJECT_DIR"
    if node "$temp_script.js"; then
        rm -f "$temp_script.js"
        
        # Committer les changements
        print_step "Commit des fichiers de release..."
        git add changelog.json package.json CHANGELOG.md
        
        local new_version
        new_version=$(get_project_version)
        
        if git commit -m "chore: release v${new_version}

- Update version to ${new_version}
- Add changelog entries
- Generate CHANGELOG.md"; then
            
            print_success "‚úÖ Release v${new_version} commit√©e"
            
            # Proposer de cr√©er un tag
            echo ""
            echo "üìå Voulez-vous cr√©er un tag Git pour cette release? (O/n): "
            read -n 1 tag_confirm
            echo ""
            
            if [[ "$tag_confirm" =~ ^[Oo]$ ]] || [[ -z "$tag_confirm" ]]; then
                git tag -a "v${new_version}" -m "Release v${new_version}"
                print_success "üè∑Ô∏è  Tag v${new_version} cr√©√©"
            fi
            
            # Proposer de push
            echo ""
            echo "üöÄ Voulez-vous pousser vers le d√©p√¥t distant? (O/n): "
            read -n 1 push_confirm
            echo ""
            
            if [[ "$push_confirm" =~ ^[Oo]$ ]] || [[ -z "$push_confirm" ]]; then
                print_step "Push vers origin..."
                if git push origin main; then
                    if git tag -l "v${new_version}" >/dev/null 2>&1; then
                        git push origin "v${new_version}"
                        print_success "üè∑Ô∏è  Tag pouss√© - GitHub Actions va se d√©clencher!"
                    fi
                    print_success "üéâ Release publi√©e avec succ√®s!"
                    echo ""
                    echo "üåê Actions automatiques d√©clench√©es:"
                    echo "  ‚Ä¢ GitHub Actions Release workflow"
                    echo "  ‚Ä¢ Publication automatique du changelog"
                    echo "  ‚Ä¢ Notification Discord (si configur√©e)"
                else
                    print_warning "Erreur lors du push"
                fi
            fi
        else
            print_error "Erreur lors du commit de release"
            rm -f "$temp_script.js"
            return 1
        fi
    else
        rm -f "$temp_script.js"
        return 1
    fi
}

# Fonction pour finaliser une feature (commit + push + merge)
finalize_feature() {
    local branch_name
    branch_name=$(git branch --show-current 2>/dev/null)
    
    if [[ -z "$branch_name" ]]; then
        print_error "Impossible de d√©terminer la branche actuelle"
        return 1
    fi
    
    if [[ "$branch_name" == "main" ]] || [[ "$branch_name" == "master" ]]; then
        print_error "Vous √™tes d√©j√† sur la branche principale"
        echo "üí° Cette commande est pour finaliser une feature branch"
        return 1
    fi
    
    print_section "Finalisation de la feature: $branch_name"
    
    # D√©tecter le type et le nom de la feature
    local feature_type=""
    local feature_name=""
    local feature_description=""
    
    if [[ "$branch_name" =~ feature/command-(.+) ]]; then
        feature_type="command"
        feature_name="${BASH_REMATCH[1]}"
        feature_description="Nouvelle commande Discord: /${feature_name}"
    elif [[ "$branch_name" =~ feature/event-(.+) ]]; then
        feature_type="event"
        feature_name="${BASH_REMATCH[1]}"
        feature_description="Nouvel √©v√©nement Discord: ${feature_name}"
    else
        feature_type="feature"
        feature_name="$branch_name"
        feature_description="Nouvelle fonctionnalit√©: $branch_name"
    fi
    
    echo "üîç Feature d√©tect√©e:"
    echo "  ‚Ä¢ Type: $feature_type"
    echo "  ‚Ä¢ Nom: $feature_name"
    echo "  ‚Ä¢ Description: $feature_description"
    echo ""
    
    # Demander confirmation
    echo "Voulez-vous finaliser cette feature? (O/n): "
    read -n 1 confirm
    echo ""
    
    if [[ ! "$confirm" =~ ^[Oo]$ ]] && [[ -n "$confirm" ]]; then
        print_warning "Finalisation annul√©e"
        return 1
    fi
    
    # 1. Commit des changements restants
    if ! git diff --quiet || ! git diff --cached --quiet; then
        print_step "Commit des derniers changements..."
        git add .
        git commit -m "feat: finalize $feature_type '$feature_name'

- Complete implementation of $feature_name
- Ready for merge to main" || {
            print_warning "Aucun changement √† committer ou erreur de commit"
        }
    fi
    
    # 2. Push de la branche
    print_step "Push de la branche vers origin..."
    if git push -u origin "$branch_name"; then
        print_success "‚úÖ Branche pouss√©e vers origin"
    else
        print_warning "Erreur lors du push - continuons quand m√™me"
    fi
    
    # 3. Ajouter au changelog pending
    print_step "Ajout au changelog..."
    add_pending_feature "$feature_type" "$feature_name" "$feature_description"
    
    # 4. Merger vers main
    print_step "Merge vers main..."
    
    # R√©cup√©rer les derni√®res modifications de main
    git fetch origin main 2>/dev/null || true
    
    # Basculer sur main
    git checkout main
    git pull origin main 2>/dev/null || true
    
    # Merger la feature
    if git merge --no-ff "$branch_name" -m "feat: merge $feature_type '$feature_name'

- Merged feature branch: $branch_name
- Added to changelog pending list"; then
        
        print_success "‚úÖ Feature merg√©e vers main"
        
        # 5. Push main
        print_step "Push de main..."
        if git push origin main; then
            print_success "‚úÖ Main pouss√© vers origin"
            
            # 6. Nettoyer la branche
            echo ""
            echo "üßπ Voulez-vous supprimer la branche feature locale? (O/n): "
            read -n 1 delete_confirm
            echo ""
            
            if [[ "$delete_confirm" =~ ^[Oo]$ ]] || [[ -z "$delete_confirm" ]]; then
                git branch -d "$branch_name"
                print_success "üóëÔ∏è  Branche locale supprim√©e"
                
                echo "Voulez-vous aussi supprimer la branche distante? (o/N): "
                read -n 1 delete_remote_confirm
                echo ""
                
                if [[ "$delete_remote_confirm" =~ ^[Oo]$ ]]; then
                    git push origin --delete "$branch_name"
                    print_success "üóëÔ∏è  Branche distante supprim√©e"
                fi
            fi
            
            # 7. Proposer de cr√©er une release
            echo ""
            echo "üéØ Feature finalis√©e avec succ√®s!"
            echo ""
            echo "üöÄ Voulez-vous cr√©er une release maintenant? (o/N): "
            read -n 1 release_confirm
            echo ""
            
            if [[ "$release_confirm" =~ ^[Oo]$ ]]; then
                echo "Type de release (patch/minor/major) [patch]: "
                read version_type
                version_type=${version_type:-patch}
                
                create_release "$version_type" "Release avec $feature_name"
            else
                echo "üí° Pour cr√©er une release plus tard:"
                echo "   pcr release --type patch"
            fi
            
        else
            print_error "Erreur lors du push de main"
            return 1
        fi
    else
        print_error "Erreur lors du merge"
        echo "üí° R√©solvez les conflits manuellement puis r√©essayez"
        return 1
    fi
}

# Fonction de commit automatique apr√®s cr√©ation
auto_commit_and_push() {
    local type="$1"      # "command" ou "event"
    local name="$2"
    local file_path="$3"
    local description="$4"  # Description optionnelle
    local branch_name="feature/${type}-${name}"
    
    # V√©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        return 0
    fi
    
    print_step "Commit automatique du nouveau $type '$name'..."
    
    # Ajouter le fichier cr√©√©
    git add "$file_path"
    
    # Cr√©er le message de commit
    local commit_msg
    if [[ "$type" == "command" ]]; then
        commit_msg="feat: add new Discord command '$name'

- Generated using 'pcr command --name $name'
- File: $(basename "$file_path")
- Ready for implementation"
    else
        commit_msg="feat: add new Discord event '$name'

- Generated using 'pcr event --name $name' 
- File: $(basename "$file_path")
- Ready for implementation"
    fi
    
    # Effectuer le commit
    if git commit -m "$commit_msg"; then
        print_success "Commit effectu√© avec succ√®s"
        
        # Demander si on veut push
        echo ""
        echo "Voulez-vous pousser la branche vers le d√©p√¥t distant? (O/n): "
        read -n 1 push_confirm
        echo ""
        if [[ "$push_confirm" =~ ^[Oo]$ ]] || [[ -z "$push_confirm" ]]; then
            print_step "Push de la branche '$branch_name'..."
            if git push -u origin "$branch_name"; then
                print_success "Branche pouss√©e vers origin/$branch_name"
                echo ""
                echo "üåê Actions sugg√©r√©es:"
                echo "  ‚Ä¢ Cr√©er une Pull Request sur GitHub/GitLab"
                echo "  ‚Ä¢ Continuer le d√©veloppement sur cette branche"
                echo "  ‚Ä¢ Merger quand pr√™t: git checkout main && git merge $branch_name"
                
                # Cr√©er l'annonce de fonctionnalit√©
                create_changelog_announcement "$type" "$name" "$description"
                
            else
                print_warning "Erreur lors du push - vous pouvez le faire manuellement plus tard"
                echo "  Commande: git push -u origin $branch_name"
            fi
        else
            print_success "Branche cr√©√©e localement (non pouss√©e)"
            echo ""
            echo "üí° Pour pousser plus tard:"
            echo "  git push -u origin $branch_name"
            
            # Cr√©er l'annonce m√™me en local
            create_changelog_announcement "$type" "$name" "$description"
        fi
    else
        print_error "Erreur lors du commit"
        return 1
    fi
}

# Fonction pour publier un changelog manuel
publish_manual_changelog() {
    local version="$1"
    local title="$2"
    
    print_step "Analyse des commits r√©cents pour le changelog..."
    
    # R√©cup√©rer les commits depuis le dernier tag ou les 10 derniers
    local last_tag
    last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
    
    local commits_range
    if [[ -n "$last_tag" ]]; then
        commits_range="${last_tag}..HEAD"
        echo "üìç Analyse depuis le tag: $last_tag"
    else
        commits_range="HEAD~10..HEAD"
        echo "üìç Analyse des 10 derniers commits"
    fi
    
    # Analyser les commits pour extraire les fonctionnalit√©s
    local features_json="/tmp/pcr_features_$$"
    cat > "${features_json}.js" << EOF
import { Client, GatewayIntentBits } from 'discord.js';
import { announceChangelog } from '${PROJECT_DIR}/modules/changelog.js';
import dotenv from 'dotenv';
import { execSync } from 'child_process';
dotenv.config();

const client = new Client({
    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]
});

client.once('ready', async () => {
    console.log('ü§ñ Bot connect√© pour le changelog...');
    
    try {
        // R√©cup√©rer les commits
        const commits = execSync('git log ${commits_range} --oneline --grep="feat:" || true', {
            cwd: '${PROJECT_DIR}',
            encoding: 'utf8'
        }).trim().split('\n').filter(line => line.length > 0);
        
        const features = [];
        
        commits.forEach(commit => {
            const match = commit.match(/feat: add new Discord (command|event) '([^']+)'/);
            if (match) {
                const [, type, name] = match;
                features.push({
                    type: type,
                    name: name,
                    description: \`Nouvelle fonctionnalit√©: \${name}\`
                });
            } else if (commit.includes('feat:')) {
                // Autres types de fonctionnalit√©s
                const name = commit.split(' ').slice(1).join(' ').replace(/^feat: /, '');
                features.push({
                    type: 'feature',
                    name: name.substring(0, 50) + (name.length > 50 ? '...' : ''),
                    description: name
                });
            }
        });
        
        if (features.length === 0) {
            console.log('‚ö†Ô∏è  Aucune nouvelle fonctionnalit√© trouv√©e dans les commits r√©cents');
            process.exit(0);
        }
        
        await announceChangelog(client, {
            version: '${version}',
            title: '${title:-Changelog PCR Bot}',
            features: features
        });
        
        console.log(\`‚úÖ Changelog publi√© avec \${features.length} fonctionnalit√©(s)\`);
    } catch (error) {
        console.error('‚ùå Erreur lors du changelog:', error.message);
    }
    
    process.exit(0);
});

client.login(process.env.DISCORD_TOKEN).catch(error => {
    console.error('‚ùå Erreur de connexion Discord:', error.message);
    console.log('‚ö†Ô∏è  Assurez-vous que DISCORD_TOKEN est configur√© dans .env');
    process.exit(1);
});
EOF

    # V√©rifier si le bot peut se connecter
    if [[ -f "$PROJECT_DIR/.env" ]] && grep -q "DISCORD_TOKEN=" "$PROJECT_DIR/.env"; then
        echo ""
        echo "üìä Fonctionnalit√©s d√©tect√©es depuis les commits r√©cents:"
        git log $commits_range --oneline --grep="feat:" | head -5 || echo "Aucune fonctionnalit√© d√©tect√©e"
        echo ""
        echo "üì¢ Voulez-vous publier le changelog version $version? (O/n): "
        read -n 1 publish_confirm
        echo ""
        
        if [[ "$publish_confirm" =~ ^[Oo]$ ]] || [[ -z "$publish_confirm" ]]; then
            cd "$PROJECT_DIR"
            timeout 30s node "${features_json}.js" 2>/dev/null || {
                print_warning "Impossible de publier le changelog automatiquement"
                echo "üí° V√©rifiez la configuration Discord et r√©essayez"
            }
        fi
    else
        print_warning "Token Discord non configur√©"
        echo "üí° Configurez DISCORD_TOKEN dans .env pour publier des changelogs"
    fi
    
    # Nettoyer le fichier temporaire
    rm -f "${features_json}.js"
}

# Fonction pour cr√©er une annonce de changelog
create_changelog_announcement() {
    local type="$1"
    local name="$2"
    local description="$3"
    
    print_step "Cr√©ation de l'annonce de fonctionnalit√©..."
    
    # Cr√©er le script Node.js temporaire pour l'annonce
    local temp_script="/tmp/pcr_announce_$$"
    cat > "$temp_script.js" << EOF
import { Client, GatewayIntentBits } from 'discord.js';
import { announceNewFeature } from '${PROJECT_DIR}/modules/changelog.js';
import dotenv from 'dotenv';
dotenv.config();

const client = new Client({
    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]
});

client.once('ready', async () => {
    console.log('ü§ñ Bot connect√© pour l\\'annonce...');
    
    try {
        await announceNewFeature(client, {
            type: '${type}',
            name: '${name}',
            description: '${description:-Nouvelle fonctionnalit√© ajout√©e}',
            author: '$(git config user.name || echo "D√©veloppeur PCR")',
            version: 'En d√©veloppement'
        });
        
        console.log('‚úÖ Annonce publi√©e avec succ√®s');
    } catch (error) {
        console.error('‚ùå Erreur lors de l\\'annonce:', error.message);
    }
    
    process.exit(0);
});

client.login(process.env.DISCORD_TOKEN).catch(error => {
    console.error('‚ùå Erreur de connexion Discord:', error.message);
    console.log('‚ö†Ô∏è  Assurez-vous que DISCORD_TOKEN est configur√© dans .env');
    process.exit(1);
});
EOF

    # V√©rifier si le bot peut se connecter
    if [[ -f "$PROJECT_DIR/.env" ]] && grep -q "DISCORD_TOKEN=" "$PROJECT_DIR/.env"; then
        echo ""
        echo "üì¢ Voulez-vous publier l'annonce de cette fonctionnalit√© dans le canal changelog? (O/n): "
        read -n 1 announce_confirm
        echo ""
        
        if [[ "$announce_confirm" =~ ^[Oo]$ ]] || [[ -z "$announce_confirm" ]]; then
            cd "$PROJECT_DIR"
            timeout 30s node "$temp_script.js" 2>/dev/null || {
                print_warning "Impossible de publier l'annonce automatiquement"
                echo "üí° Vous pouvez publier manuellement l'annonce plus tard avec:"
                echo "   node -e \"import('./modules/changelog.js').then(m => console.log('Module charg√©'))\""
            }
        fi
    else
        print_warning "Token Discord non configur√© - annonce ignor√©e"
        echo "üí° Configurez DISCORD_TOKEN dans .env pour activer les annonces automatiques"
    fi
    
    # Nettoyer le fichier temporaire
    rm -f "$temp_script.js"
}

# Fonction de cr√©ation d'√©v√©nement
create_event() {
    local event_name="$1"
    
    if [[ -z "$event_name" ]]; then
        print_error "Nom d'√©v√©nement requis"
        echo "Usage: pcr event --name <nom_evenement>"
        echo "Exemple: pcr event --name messageUpdate"
        return 1
    fi
    
    # Cr√©er la branche Git automatiquement
    create_git_branch "event" "$event_name"
    
    # V√©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$event_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom d'√©v√©nement invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local events_dir="$PROJECT_DIR/events/client"
    local example_file="$events_dir/example"
    local new_event_file="$events_dir/$event_name.js"
    
    # V√©rifier si le fichier example existe
    if [[ ! -f "$example_file" ]]; then
        print_error "Fichier template non trouv√©: $example_file"
        return 1
    fi
    
    # V√©rifier si l'√©v√©nement existe d√©j√†
    if [[ -f "$new_event_file" ]]; then
        print_error "L'√©v√©nement '$event_name' existe d√©j√†"
        print_warning "Fichier existant: $new_event_file"
        return 1
    fi
    
    print_step "Cr√©ation de l'√©v√©nement '$event_name'..."
    
    # Copier le template et remplacer les valeurs par d√©faut
    cp "$example_file" "$new_event_file"
    
    # Remplacer 'name' par le nom de l'√©v√©nement
    sed -i "s/const name = 'name'/const name = '$event_name'/g" "$new_event_file"
    
    # Ajouter un commentaire d'identification
    sed -i "1i// √âv√©nement: $event_name" "$new_event_file"
    sed -i "2i//" "$new_event_file"
    
    print_success "√âv√©nement '$event_name' cr√©√© avec succ√®s!"
    print_success "Fichier: $new_event_file"
    
    # Commit automatique et push
    auto_commit_and_push "event" "$event_name" "$new_event_file" "Nouvel √©v√©nement Discord pour g√©rer $event_name"
    
    echo ""
    echo "üìù Prochaines √©tapes:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  1. √âditez le fichier pour personnaliser l'√©v√©nement"
    echo "  2. Modifiez la propri√©t√© 'once' (true/false)"
    echo "  3. Impl√©mentez la logique dans la fonction execute"
    echo "  4. Red√©marrez le bot: pcr restart"
    echo ""
    echo "üí° Commandes utiles:"
    echo "  ‚Ä¢ √âditer: nano $new_event_file"
    echo "  ‚Ä¢ Voir les logs: pcr logs"
    echo ""
    echo "üåø Git workflow:"
    echo "  ‚Ä¢ Branche courante: feature/event-$event_name"
    echo "  ‚Ä¢ Quand pr√™t: cr√©er une Pull Request"
    echo "  ‚Ä¢ Revenir √† main: git checkout main"
    echo ""
    echo "üìö √âv√©nements Discord courants:"
    echo "  ‚Ä¢ ready, messageCreate, messageDelete"
    echo "  ‚Ä¢ guildMemberAdd, guildMemberRemove"
    echo "  ‚Ä¢ interactionCreate, messageReactionAdd"
}

# Fonction de cr√©ation de commande
create_command() {
    local command_name="$1"
    local command_desc="$2"
    
    if [[ -z "$command_name" ]]; then
        print_error "Nom de commande requis"
        echo "Usage: pcr command --name <nom_commande> [--desc <description>]"
        echo "Exemple: pcr command --name hello"
        echo "Exemple: pcr command --name hello --desc \"Commande de salutation\""
        return 1
    fi
    
    # Cr√©er la branche Git automatiquement
    create_git_branch "command" "$command_name"
    
    # V√©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$command_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom de commande invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local commands_dir="$PROJECT_DIR/commands"
    local example_file="$commands_dir/example"
    local new_command_file="$commands_dir/$command_name.js"
    
    # V√©rifier si le fichier example existe
    if [[ ! -f "$example_file" ]]; then
        print_error "Fichier template non trouv√©: $example_file"
        return 1
    fi
    
    # V√©rifier si la commande existe d√©j√†
    if [[ -f "$new_command_file" ]]; then
        print_error "La commande '$command_name' existe d√©j√†"
        print_warning "Fichier existant: $new_command_file"
        return 1
    fi
    
    print_step "Cr√©ation de la commande '$command_name'..."
    
    # Copier le template et remplacer les valeurs par d√©faut
    cp "$example_file" "$new_command_file"
    
    # Remplacer 'name' par le nom de la commande
    sed -i "s/\.setName('name')/\.setName('$command_name')/g" "$new_command_file"
    
    # Remplacer 'Description' par une description personnalis√©e
    if [[ -n "$command_desc" ]]; then
        # Utiliser la description fournie
        sed -i "s/\.setDescription('Description')/\.setDescription('$command_desc')/g" "$new_command_file"
    else
        # Utiliser une description par d√©faut
        sed -i "s/\.setDescription('Description')/\.setDescription('Description de la commande $command_name')/g" "$new_command_file"
    fi
    
    print_success "Commande '$command_name' cr√©√©e avec succ√®s!"
    print_success "Fichier: $new_command_file"
    
    # Commit automatique et push
    local desc_for_changelog="${command_desc:-Nouvelle commande Discord: $command_name}"
    auto_commit_and_push "command" "$command_name" "$new_command_file" "$desc_for_changelog"
    
    echo ""
    echo "üìù Prochaines √©tapes:"
    echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
    echo "  1. √âditez le fichier pour personnaliser la commande"
    echo "  2. Modifiez la description et les options"
    echo "  3. Impl√©mentez la logique dans la fonction execute"
    echo "  4. Red√©marrez le bot: pcr restart"
    echo ""
    echo "üí° Commandes utiles:"
    echo "  ‚Ä¢ √âditer: nano $new_command_file"
    echo "  ‚Ä¢ Voir les logs: pcr logs"
    echo ""
    echo "üåø Git workflow:"
    echo "  ‚Ä¢ Branche courante: feature/command-$command_name"
    echo "  ‚Ä¢ Quand pr√™t: cr√©er une Pull Request"
    echo "  ‚Ä¢ Revenir √† main: git checkout main"
}

# Fonction d'installation du script dans le PATH
install_script() {
    local script_path="/usr/local/bin/pcr"
    
    if [[ -f "$script_path" ]]; then
        echo -n "Le script est d√©j√† install√©. Voulez-vous le mettre √† jour? (O/n): "
        read -n 1 confirmation
        echo ""
        if [[ ! "$confirmation" =~ ^[Oo]$ ]] && [[ -n "$confirmation" ]]; then
            print_warning "Installation annul√©e"
            return 1
        fi
    fi
    
    print_step "Installation du script pcr dans /usr/local/bin..."
    
    # Copier le script
    if sudo cp "$PROJECT_DIR/pcr" "$script_path"; then
        sudo chmod +x "$script_path"
        print_success "Script install√© avec succ√®s!"
        print_success "Vous pouvez maintenant utiliser 'pcr' depuis n'importe o√π"
        echo ""
        echo "üí° Conseils:"
        echo "  - Utilisez 'pcr' depuis le r√©pertoire du projet ou ses sous-r√©pertoires"
        echo "  - Le script d√©tectera automatiquement le bon r√©pertoire de projet"
        echo "  - Pour d√©sinstaller: sudo rm /usr/local/bin/pcr"
    else
        print_error "Erreur lors de l'installation (permissions sudo requises)"
        return 1
    fi
}

case "$1" in
    dev)
        validate_project_directory
        echo "üöÄ Lancement du mode d√©veloppement..."
        echo ""
        print_step "D√©marrage du bot en mode d√©veloppement..."
        cd "$PROJECT_DIR"
        npm run dev
        ;;
    start)
        validate_project_directory
        print_section "D√©marrage du Bot PCR"
        cd "$PROJECT_DIR"
        pm2 start index.js --name pcr 2>/dev/null || {
            print_warning "Processus d√©j√† en cours, tentative de red√©marrage..."
            pm2 restart pcr
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "üéâ Bot PCR d√©marr√© avec succ√®s!"
            echo ""
            echo "üìä Informations du bot:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "ü§ñ Nom: PCR Discord Bot"
            echo "üìÅ R√©pertoire: $PROJECT_DIR"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ pcr status   - V√©rifier l'√©tat"
            echo "  ‚Ä¢ pcr logs     - Voir les logs"
            echo "  ‚Ä¢ pcr monitor  - Monitoring complet"
        else
            print_error "‚ùå √âchec du d√©marrage"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "  ‚Ä¢ V√©rifiez les logs: pcr logs"
            echo "  ‚Ä¢ V√©rifiez les permissions"
            echo "  ‚Ä¢ Red√©marrez: pcr restart"
        fi
        ;;
    stop)
        print_section "Arr√™t du Bot PCR"
        pm2 stop pcr 2>/dev/null || print_warning "Bot d√©j√† arr√™t√©"
        echo ""
        print_success "üõë Bot PCR arr√™t√© avec succ√®s"
        echo ""
        echo "üí° Pour red√©marrer:"
        echo "  ‚Ä¢ pcr start    - D√©marrer le bot"
        echo "  ‚Ä¢ pcr restart  - Red√©marrer directement"
        ;;
    restart)
        print_section "Red√©marrage du Bot PCR"
        cd "$PROJECT_DIR"
        pm2 restart pcr 2>/dev/null || {
            print_warning "Processus non trouv√©, d√©marrage..."
            pm2 start index.js --name pcr
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "üîÑ Bot PCR red√©marr√© avec succ√®s!"
            echo ""
            echo "üìä Informations du bot:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "ü§ñ Nom: PCR Discord Bot"
            echo "üìÅ R√©pertoire: $PROJECT_DIR"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ pcr logs     - Voir les logs"
            echo "  ‚Ä¢ pcr monitor  - Monitoring complet"
        else
            print_error "‚ùå √âchec du red√©marrage"
            echo ""
            echo "üîç V√©rifications sugg√©r√©es:"
            echo "  ‚Ä¢ V√©rifiez les logs: pcr logs"
            echo "  ‚Ä¢ Essayez un arr√™t/d√©marrage: pcr stop && pcr start"
        fi
        ;;
    status)
        print_section "Statut du Bot PCR"
        if check_app_status; then
            print_success "üü¢ Bot PCR en ligne"
            echo ""
            echo "üìä Informations rapides:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "ü§ñ Processus PM2: Actif"
            echo "üìÅ R√©pertoire: $PROJECT_DIR"
            echo ""
            echo "üí° Commandes utiles:"
            echo "  ‚Ä¢ pcr logs     - Voir les logs en temps r√©el"
            echo "  ‚Ä¢ pcr monitor  - Monitoring d√©taill√©"
        else
            print_error "üî¥ Bot PCR hors ligne"
            echo ""
            echo "üîç Actions sugg√©r√©es:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ pcr start    - D√©marrer le bot"
            echo "  ‚Ä¢ pcr logs     - V√©rifier les erreurs"
            echo "  ‚Ä¢ pcr deploy   - Red√©ployer si n√©cessaire"
        fi
        ;;
    logs)
        print_section "Logs du Bot PCR"
        echo "üìã Affichage en temps r√©el (Ctrl+C pour arr√™ter)"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        pm2 logs pcr 2>/dev/null || {
            print_error "Impossible d'acc√©der aux logs"
            echo ""
            echo "üîç V√©rifications:"
            echo "  ‚Ä¢ Le bot est-il d√©marr√©? pcr status"
            echo "  ‚Ä¢ Essayez de red√©marrer: pcr restart"
        }
        ;;
    monitor)
        monitor_function
        ;;
    update)
        update_function
        ;;
    deploy)
        echo "üöÄ D√©ploiement du bot PCR..."
        cd "$PROJECT_DIR"
        
        # Sauvegarde automatique avant d√©ploiement
        print_step "Sauvegarde automatique avant d√©ploiement..."
        backup_database || echo "Continuer sans sauvegarde..."
        
        # V√©rification et cr√©ation du fichier .env
        print_step "V√©rification de la configuration d'environnement..."
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env cr√©√© √† partir de .env.example"
                print_warning "N'oubliez pas de configurer vos tokens dans .env"
            else
                print_warning "Ni .env ni .env.example trouv√©s"
                print_warning "Assurez-vous d'avoir configur√© vos variables d'environnement"
            fi
        else
            print_success "Fichier .env d√©j√† pr√©sent"
        fi
        
        # Arr√™t de l'application
        print_step "Arr√™t du bot si il est en cours d'ex√©cution..."
        pm2 stop pcr 2>/dev/null || echo "Bot pas encore d√©marr√©"

        # Installation des d√©pendances
        print_step "Installation des d√©pendances..."
        npm install

        # D√©marrage du bot avec PM2
        print_step "D√©marrage du bot avec PM2..."
        pm2 start index.js --name pcr

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # V√©rification finale
        sleep 5
        if check_app_status; then
            print_success "üéâ D√©ploiement termin√© avec succ√®s!"
            print_success "Bot PCR Discord en ligne"
        else
            print_error "‚ùå Probl√®me lors du d√©ploiement"
        fi
        ;;
    event)
        # Gestion des options pour la commande event
        validate_project_directory
        
        # Parser les arguments
        event_name=""
        no_git=false
        
        # Analyser les param√®tres
        shift # Enlever 'event'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --name)
                    event_name="$2"
                    shift 2
                    ;;
                --no-git)
                    no_git=true
                    shift
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr event --name <nom_evenement> [--no-git]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$event_name" ]]; then
            if [[ "$no_git" == true ]]; then
                # Sauvegarder les fonctions Git temporairement
                create_git_branch() { return 0; }
                auto_commit_and_push() { return 0; }
            fi
            create_event "$event_name"
        else
            print_error "Usage: pcr event --name <nom_evenement> [--no-git]"
            echo "Exemple: pcr event --name messageUpdate"
            echo "Options:"
            echo "  --no-git    Skip Git branch creation and commit"
            echo ""
            echo "Cette commande cr√©e un nouvel √©v√©nement Discord en utilisant"
            echo "le template du fichier 'example' dans le dossier events/client/"
            echo ""
            echo "üìö √âv√©nements Discord courants:"
            echo "  ‚Ä¢ ready, messageCreate, messageDelete, messageUpdate"
            echo "  ‚Ä¢ guildMemberAdd, guildMemberRemove, guildMemberUpdate"
            echo "  ‚Ä¢ interactionCreate, messageReactionAdd, messageReactionRemove"
        fi
        ;;
    command)
        # Gestion des options pour la commande command
        validate_project_directory
        
        # Parser les arguments
        command_name=""
        command_desc=""
        no_git=false
        
        # Analyser les param√®tres
        shift # Enlever 'command'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --name)
                    command_name="$2"
                    shift 2
                    ;;
                --desc)
                    command_desc="$2"
                    shift 2
                    ;;
                --no-git)
                    no_git=true
                    shift
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr command --name <nom_commande> [--desc <description>] [--no-git]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$command_name" ]]; then
            if [[ "$no_git" == true ]]; then
                # Sauvegarder les fonctions Git temporairement
                create_git_branch() { return 0; }
                auto_commit_and_push() { return 0; }
            fi
            create_command "$command_name" "$command_desc"
        else
            print_error "Usage: pcr command --name <nom_commande> [--desc <description>] [--no-git]"
            echo "Exemple: pcr command --name hello"
            echo "Exemple: pcr command --name hello --desc \"Commande de salutation\""
            echo "Options:"
            echo "  --no-git    Skip Git branch creation and commit"
            echo ""
            echo "Cette commande cr√©e une nouvelle commande Discord en utilisant"
            echo "le template du fichier 'example' dans le dossier commands/"
        fi
        ;;
    changelog)
        # Gestion de la publication de changelog
        validate_project_directory
        
        # Parser les arguments
        version=""
        title=""
        
        # Analyser les param√®tres
        shift # Enlever 'changelog'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --version)
                    version="$2"
                    shift 2
                    ;;
                --title)
                    title="$2"
                    shift 2
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr changelog --version <version> [--title <titre>]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$version" ]]; then
            publish_manual_changelog "$version" "$title"
        else
            print_error "Usage: pcr changelog --version <version> [--title <titre>]"
            echo "Exemple: pcr changelog --version 1.2.0 --title \"Mise √† jour majeure\""
            echo ""
            echo "Cette commande publie un changelog dans le canal configur√©"
            echo "en analysant les commits r√©cents pour d√©tecter les nouvelles fonctionnalit√©s."
        fi
        ;;
    branches)
        validate_project_directory
        list_feature_branches
        ;;
    install)
        install_script
        ;;
    backup)
        validate_project_directory
        print_section "Sauvegarde de la Base de Donn√©es"
        if backup_database; then
            echo ""
            echo "üí° Commandes utiles:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ pcr restore <fichier>  - Restaurer une sauvegarde"
            echo "  ‚Ä¢ ls -la $BACKUP_DIR     - Voir toutes les sauvegardes"
        else
            echo ""
            echo "üîç V√©rifications:"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "  ‚Ä¢ La base de donn√©es existe-t-elle?"
            echo "  ‚Ä¢ Le bot a-t-il √©t√© initialis√©? pcr deploy"
        fi
        ;;
    restore)
        validate_project_directory
        if [[ -n "$2" ]]; then
            print_section "Restauration de la Base de Donn√©es"
            restore_database "$2"
        else
            print_section "Sauvegardes Disponibles"
            if ls "$BACKUP_DIR"/*.db 1> /dev/null 2>&1; then
                ls -la "$BACKUP_DIR"/*.db
                echo ""
                echo "Usage: pcr restore <fichier_backup>"
                echo "Exemple:"
                echo "  pcr restore $BACKUP_DIR/$(ls "$BACKUP_DIR"/*.db 2>/dev/null | head -1 | xargs basename)"
            else
                print_warning "Aucune sauvegarde trouv√©e"
                echo ""
                echo "üí° Pour cr√©er une sauvegarde:"
                echo "  pcr backup"
            fi
        fi
        ;;
    reset)
        # V√©rifier si l'option --y ou -y est pr√©sente
        auto_confirm=false
        if [[ "$2" == "--y" ]] || [[ "$2" == "-y" ]]; then
            auto_confirm=true
        fi
        
        echo "üîÑ R√©initialisation compl√®te du bot PCR..."
        echo ""
        echo -e "${YELLOW}‚ö†Ô∏è  ATTENTION: Cette action va supprimer toutes les donn√©es!${NC}"
        echo -e "${YELLOW}‚ö†Ô∏è  Les messages, configurations et donn√©es du bot seront perdues!${NC}"
        echo ""
        
        # Sauvegarde de s√©curit√© avant reset
        if [[ "$auto_confirm" != true ]]; then
            echo "üíæ Cr√©ation d'une sauvegarde de s√©curit√© avant reset..."
            backup_database || echo "Continuer sans sauvegarde..."
            echo ""
        fi
        
        if [ "$auto_confirm" = true ]; then
            echo "Mode automatique activ√© (--y), confirmation ignor√©e"
            confirmation="o"
        else
            echo -n "√ätes-vous s√ªr de vouloir continuer? (O/n): "
            read -n 1 confirmation
            echo ""
        fi
        
        if [[ "$confirmation" =~ ^[Oo]$ ]] || [ -z "$confirmation" ]; then
            cd "$PROJECT_DIR" || {
                print_error "Impossible d'acc√©der au r√©pertoire $PROJECT_DIR"
                exit 1
            }

            # Suppression des logs
            print_step "Suppression des logs..."
            if [ -d "$LOG_DIR" ]; then
                rm -rf "$LOG_DIR"/*
                print_success "Logs supprim√©s et r√©pertoire recr√©√©"
            else
                mkdir -p "$LOG_DIR"
            fi

            # Suppression de la base de donn√©es
            print_step "Suppression de la base de donn√©es..."
            db_path=$(find_database_path)
            if [[ -f "$db_path" ]]; then
                rm -f "$db_path"
                print_success "Base de donn√©es supprim√©e"
            fi

            # Arr√™t et suppression du processus PM2
            print_step "Arr√™t du processus PM2..."
            pm2 stop pcr 2>/dev/null || echo "Processus d√©j√† arr√™t√©"
            pm2 delete pcr 2>/dev/null || echo "Processus non trouv√©"

            # R√©installation des d√©pendances
            print_step "R√©installation des d√©pendances..."
            rm -rf node_modules package-lock.json
            npm install

            # Red√©marrage
            print_step "Red√©marrage du bot..."
            pm2 start index.js --name pcr
            pm2 save
            
            sleep 2
            if check_app_status; then
                print_success "üéâ R√©initialisation termin√©e avec succ√®s!"
                print_success "Bot PCR red√©marr√© avec une configuration propre"
            else
                print_error "‚ùå Erreur lors de la r√©initialisation"
            fi
        else
            print_warning "R√©initialisation annul√©e"
        fi
        ;;
    finish|finalize)
        validate_project_directory
        finalize_feature
        ;;
    release)
        validate_project_directory
        shift
        version_type="patch"
        title=""
        
        while [[ $# -gt 0 ]]; do
            case $1 in
                --type)
                    version_type="$2"
                    shift 2
                    ;;
                --title)
                    title="$2"
                    shift 2
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr release [--type patch|minor|major] [--title \"Titre\"]"
                    exit 1
                    ;;
            esac
        done
        
        create_release "$version_type" "$title"
        ;;
    changelog-status)
        validate_project_directory
        print_section "Statut du Changelog"
        
        # Cr√©er le script Node.js temporaire
        temp_script="/tmp/pcr_changelog_status_$$"
        cat > "$temp_script.js" << EOF
import { getChangelogStats } from '${PROJECT_DIR}/modules/version-manager.js';

try {
    const stats = getChangelogStats();
    
    if (stats.error) {
        console.log('‚ùå Erreur:', stats.error);
        process.exit(1);
    }
    
    console.log('üìä Statistiques du Changelog');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log(\`üì¶ Version actuelle: \${stats.currentVersion}\`);
    console.log(\`üéØ Features en attente: \${stats.pendingFeatures}\`);
    console.log(\`üìã Total releases: \${stats.totalReleases}\`);
    
    if (stats.lastRelease) {
        console.log(\`üè∑Ô∏è  Derni√®re release: \${stats.lastRelease.version} (\${stats.lastRelease.date})\`);
    }
    
    if (stats.pendingFeatures > 0) {
        console.log('\\n‚è≥ Features en attente par type:');
        Object.entries(stats.pendingByType).forEach(([type, count]) => {
            const icon = type === 'command' ? '‚ö°' : type === 'event' ? 'üéØ' : '‚ú®';
            console.log(\`   \${icon} \${type}: \${count}\`);
        });
    }
    
    console.log('\\nüí° Commandes disponibles:');
    console.log('  ‚Ä¢ pcr finish     - Finaliser la feature actuelle');
    console.log('  ‚Ä¢ pcr release    - Cr√©er une nouvelle release');
    
} catch (error) {
    console.error('‚ùå Erreur:', error.message);
    process.exit(1);
}
EOF

        cd "$PROJECT_DIR"
        node "$temp_script.js"
        rm -f "$temp_script.js"
        ;;
    workflow)
        print_section "Guide de Workflow PCR"
        echo ""
        echo "üöÄ WORKFLOW DE D√âVELOPPEMENT PCR"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo ""
        echo "1Ô∏è‚É£  CR√âER UNE NOUVELLE FEATURE:"
        echo "   pcr command --name ma-commande    # Pour une nouvelle commande"
        echo "   pcr event --name mon-event        # Pour un nouvel √©v√©nement"
        echo "   ‚îî‚îÄ Cr√©√© automatiquement une branche feature/type-nom"
        echo ""
        echo "2Ô∏è‚É£  D√âVELOPPER LA FEATURE:"
        echo "   ‚Ä¢ Modifiez le fichier g√©n√©r√©"
        echo "   ‚Ä¢ Testez avec: pcr restart && pcr logs"
        echo "   ‚Ä¢ Commitez vos changements au fur et √† mesure"
        echo ""
        echo "3Ô∏è‚É£  FINALISER LA FEATURE:"
        echo "   pcr finish"
        echo "   ‚îî‚îÄ Commit final + push + merge vers main + ajout au changelog"
        echo ""
        echo "4Ô∏è‚É£  CR√âER UNE RELEASE:"
        echo "   pcr release --type patch          # Version x.x.X+1"
        echo "   pcr release --type minor          # Version x.X+1.0"
        echo "   pcr release --type major          # Version X+1.0.0"
        echo "   ‚îî‚îÄ Publie toutes les features pending + tag Git + GitHub Actions"
        echo ""
        echo "üìä V√âRIFIER LE STATUT:"
        echo "   pcr changelog-status              # Voir les features en attente"
        echo "   pcr branches                      # Voir les branches actives"
        echo "   pcr status                        # Statut g√©n√©ral du bot"
        echo ""
        echo "üéØ GITHUB ACTIONS AUTOMATIQUES:"
        echo "   ‚Ä¢ Push d'un tag ‚Üí D√©clenche la release GitHub"
        echo "   ‚Ä¢ Release cr√©√©e ‚Üí Publication automatique du changelog Discord"
        echo "   ‚Ä¢ Tests automatiques sur chaque push"
        echo ""
        echo "üí° BONNES PRATIQUES:"
        echo "   ‚Ä¢ Une feature = une branche"
        echo "   ‚Ä¢ Testez avant de finish"
        echo "   ‚Ä¢ Groupez plusieurs features dans une release"
        echo "   ‚Ä¢ Utilisez des messages de commit clairs"
        echo ""
        current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
        if [[ "$current_branch" != "main" ]] && [[ "$current_branch" != "master" ]]; then
            echo "üìç SITUATION ACTUELLE:"
            echo "   Branche: $current_branch"
            echo "   Action sugg√©r√©e: pcr finish (quand ready)"
        fi
        ;;
    *)
        echo -e "${PURPLE}ü§ñ PCR BOT DISCORD - Script de gestion unifi√©${NC}"
        echo "============================================="
        echo ""
        echo "Usage: pcr [commande]"
        echo ""
        echo "Commandes disponibles:"
        echo ""
        echo "üöÄ Gestion du bot:"
        echo "  start         - D√©marre le bot"
        echo "  stop          - Arr√™te le bot"
        echo "  restart       - Red√©marre le bot"
        echo "  status        - Affiche le statut du bot"
        echo ""
        echo "üìä Monitoring et logs:"
        echo "  logs          - Affiche les logs PM2 du bot en temps r√©el"
        echo "  monitor       - Monitoring complet avec ressources syst√®me"
        echo ""
        echo "üîß D√©veloppement:"
        echo "  dev           - Lance le bot en mode d√©veloppement (avec nodemon)"
        echo "  command       - Cr√©e une nouvelle commande Discord avec branche Git"
        echo "                  Usage: pcr command --name <nom> [--desc <description>] [--no-git]"
        echo "  event         - Cr√©e un nouvel √©v√©nement Discord avec branche Git"
        echo "                  Usage: pcr event --name <nom> [--no-git]"
        echo "  branches      - Liste les branches de fonctionnalit√©s PCR"
        echo "  changelog     - Publie un changelog dans Discord"
        echo "                  Usage: pcr changelog --version <version> [--title <titre>]"
        echo ""
        echo "üöÄ D√©ploiement:"
        echo "  deploy        - D√©ploiement complet du bot"
        echo "  update        - Mise √† jour du bot depuis Git"
        echo ""
        echo "üíæ Sauvegarde et restauration:"
        echo "  backup        - Sauvegarde la base de donn√©es"
        echo "  restore       - Restaure une sauvegarde (pcr restore <fichier>)"
        echo ""
        echo "‚öôÔ∏è Configuration:"
        echo "  install       - Installe le script dans le PATH global"
        echo "  reset         - R√©initialise compl√®tement le bot (‚ö†Ô∏è SUPPRIME TOUTES LES DONN√âES)"
        echo "                  Options: --y ou -y pour confirmer automatiquement"
        echo ""
        echo "Architecture:"
        echo "  üìÅ Bot Discord : PCR - Gestion communautaire"
        echo "  üìÅ Base de donn√©es : SQLite (messages.db)"
        echo "  üìÅ Logs : PM2 + fichiers locaux"
        echo ""
        exit 1
        ;;
esac

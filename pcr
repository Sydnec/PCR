#!/bin/bash

# ğŸ¤– PCR Bot Discord - Script de gestion unifiÃ©
# Usage: pcr [command]

# Auto-dÃ©tection du rÃ©pertoire du projet
# Si le script est dans /usr/local/bin, on utilise le rÃ©pertoire courant
# Sinon, on utilise le rÃ©pertoire du script

if [[ "$(realpath "$0")" == "/usr/local/bin/pcr" ]]; then
    # Script installÃ© globalement, utiliser le rÃ©pertoire courant
    PROJECT_DIR="$(pwd)"
    # VÃ©rifier si on est dans un projet PCR valide
    if [[ ! -f "index.js" ]] || [[ ! -f "package.json" ]]; then
        # Essayer de trouver le projet dans les rÃ©pertoires parents
        current_dir="$(pwd)"
        found=false
        while [[ "$current_dir" != "/" ]]; do
            if [[ -f "$current_dir/index.js" ]] && [[ -f "$current_dir/package.json" ]] && [[ -f "$current_dir/pcr" ]]; then
                PROJECT_DIR="$current_dir"
                found=true
                break
            fi
            current_dir="$(dirname "$current_dir")"
        done
        
        if [[ "$found" != true ]]; then
            PROJECT_DIR="/home/sydnec/PCR"  # Fallback
        fi
    fi
else
    # Script local, utiliser le rÃ©pertoire du script
    PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi

LOG_DIR="$PROJECT_DIR/logs"
BACKUP_DIR="$PROJECT_DIR/backups"

# Validation du rÃ©pertoire de projet
validate_project_directory() {
    if [[ ! -f "$PROJECT_DIR/index.js" ]] || [[ ! -f "$PROJECT_DIR/package.json" ]]; then
        print_error "Ce rÃ©pertoire ne semble pas Ãªtre un projet PCR valide."
        print_error "Fichiers attendus :"
        print_error "  - index.js: $PROJECT_DIR/index.js"
        print_error "  - package.json: $PROJECT_DIR/package.json"
        print_error ""
        print_error "RÃ©pertoire actuel dÃ©tectÃ© : $PROJECT_DIR"
        print_error "Assurez-vous d'Ãªtre dans le rÃ©pertoire racine du projet ou que les fichiers existent."
        exit 1
    fi
}

# CrÃ©ation du rÃ©pertoire de backup si nÃ©cessaire
ensure_backup_dir() {
    if [[ ! -d "$BACKUP_DIR" ]]; then
        mkdir -p "$BACKUP_DIR"
    fi
}

# CrÃ©ation du rÃ©pertoire de logs si nÃ©cessaire
ensure_log_dir() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
    fi
}

# Fonction pour trouver le chemin de la base de donnÃ©es
find_database_path() {
    local db_paths=(
        "$PROJECT_DIR/messages.db"
        "$PROJECT_DIR/database.db"
        "$PROJECT_DIR/bot.db"
    )
    
    for path in "${db_paths[@]}"; do
        if [[ -f "$path" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Retourner le chemin standard si aucun fichier trouvÃ©
    echo "$PROJECT_DIR/messages.db"
    return 1
}

# Fonction de sauvegarde de la base de donnÃ©es
backup_database() {
    ensure_backup_dir
    local backup_file="$BACKUP_DIR/db_backup_$(date +%Y%m%d_%H%M%S).db"
    local db_path
    
    db_path=$(find_database_path)
    
    if [[ -f "$db_path" ]]; then
        cp "$db_path" "$backup_file"
        print_success "Base de donnÃ©es sauvegardÃ©e : $backup_file"
        print_success "Source: $db_path"
        return 0
    else
        print_warning "Aucune base de donnÃ©es trouvÃ©e"
        print_warning "Emplacements vÃ©rifiÃ©s:"
        print_warning "  - $PROJECT_DIR/messages.db"
        print_warning "  - $PROJECT_DIR/database.db"
        print_warning "  - $PROJECT_DIR/bot.db"
        return 1
    fi
}

# Fonction de restauration de la base de donnÃ©es
restore_database() {
    local backup_file="$1"
    
    if [[ -z "$backup_file" ]]; then
        print_error "Fichier de sauvegarde requis"
        echo "Usage: pcr restore <fichier_backup>"
        echo "Sauvegardes disponibles:"
        ls -la "$BACKUP_DIR"/*.db 2>/dev/null || echo "Aucune sauvegarde trouvÃ©e"
        return 1
    fi
    
    if [[ ! -f "$backup_file" ]]; then
        print_error "Fichier de sauvegarde non trouvÃ©: $backup_file"
        return 1
    fi
    
    local db_path
    db_path=$(find_database_path)
    
    print_step "ArrÃªt du bot pour la restauration..."
    pm2 stop pcr 2>/dev/null || echo "Bot dÃ©jÃ  arrÃªtÃ©"
    
    print_step "Restauration de la base de donnÃ©es..."
    cp "$backup_file" "$db_path"
    print_success "Base de donnÃ©es restaurÃ©e vers: $db_path"
    
    print_step "RedÃ©marrage du bot..."
    pm2 start "$PROJECT_DIR/index.js" --name pcr
    
    if check_app_status; then
        print_success "Base de donnÃ©es restaurÃ©e avec succÃ¨s"
    else
        print_error "Erreur lors de la restauration"
    fi
}

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

print_section() {
    echo -e "${CYAN}ğŸ“Š $1${NC}"
    echo "----------------------------"
}

print_step() {
    echo -e "${GREEN}[Ã‰TAPE]${NC} $1"
}

print_success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}âš ï¸  $1${NC}"
}

print_error() {
    echo -e "${RED}âŒ $1${NC}"
}

# Fonction pour vÃ©rifier si le bot est en ligne
check_app_status() {
    if pm2 list 2>/dev/null | grep -q "pcr.*online"; then
        return 0
    else
        return 1
    fi
}

# Fonction de monitoring complÃ¨te
monitor_function() {
    clear
    echo -e "${PURPLE}ğŸ¤– PCR BOT DISCORD - MONITORING${NC}"
    echo "================================="
    echo ""
    
    # 1. Statut PM2
    print_section "Statut PM2"
    if pm2 list 2>/dev/null | grep -q "pcr"; then
        pm2 list
        echo ""
        if check_app_status; then
            print_success "Bot PCR en ligne"
        else
            print_error "Bot PCR hors ligne"
        fi
    else
        print_error "Aucun processus PM2 trouvÃ©"
    fi
    echo ""

    # 2. Ressources systÃ¨me
    print_section "Ressources systÃ¨me"
    echo "ğŸ’¾ MÃ©moire: $(free -h | awk '/^Mem:/ {printf "UtilisÃ©e: %s/%s (%.2f%%)", $3, $2, ($3/$2)*100}')"
    echo "ğŸ”¥ CPU: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//')% utilisÃ©"
    echo "ğŸ’¿ Disque: $(df -h / | awk 'NR==2 {printf "UtilisÃ©: %s/%s (%s)", $3, $2, $5}')"
    echo ""

    # 3. Informations de dÃ©ploiement
    print_section "Informations de dÃ©ploiement"
    echo "ğŸ“ RÃ©pertoire projet: $PROJECT_DIR"
    echo "ğŸ‘¤ Utilisateur: $(whoami)"
    echo "ğŸ–¥ï¸  Hostname: $(hostname)"
    echo "ğŸ“ DerniÃ¨re modification: $(stat -c %y "$PROJECT_DIR/index.js" 2>/dev/null || stat -f %Sm "$PROJECT_DIR/index.js" 2>/dev/null || echo "Non disponible")"
    echo ""

    # 4. Logs rÃ©cents
    print_section "Logs rÃ©cents (derniÃ¨res 5 lignes)"
    pm2 logs pcr --lines 5 --nostream 2>/dev/null || echo "Aucun log disponible"
    echo ""

    echo "ğŸ”„ Pour actualiser: pcr monitor"
    echo "ğŸ“Š Pour PM2 monitoring: pm2 monit"
    echo "ğŸ“‹ Pour redÃ©marrer: pcr restart"
}

# Fonction de mise Ã  jour
update_function() {
    cd "$PROJECT_DIR" || {
        print_error "Impossible d'accÃ©der au rÃ©pertoire $PROJECT_DIR"
        exit 1
    }

    print_step "ğŸ”„ Mise Ã  jour PCR Bot..."
    
    # Sauvegarde automatique avant mise Ã  jour
    print_step "Sauvegarde automatique avant mise Ã  jour..."
    backup_database || echo "Continuer sans sauvegarde..."

    # Sauvegarde des logs
    ensure_log_dir
    print_step "Sauvegarde des logs actuels..."
    if [ -f "$LOG_DIR/pcr.log" ]; then
        cp "$LOG_DIR/pcr.log" "$LOG_DIR/pcr.log.backup.$(date +%Y%m%d_%H%M%S)"
    fi

    # VÃ©rifier et arrÃªter PM2 si nÃ©cessaire
    print_step "ğŸ“‹ VÃ©rification du statut PM2..."
    if pm2 describe pcr &> /dev/null; then
        print_step "âœ… Processus PM2 'pcr' trouvÃ©"
        print_step "ArrÃªt temporaire du bot..."
        pm2 stop pcr
    else
        print_warning "âš ï¸ Processus PM2 'pcr' non trouvÃ©"
    fi

    # Stash des changements locaux non commitÃ©s (si il y en a)
    if ! git diff-index --quiet HEAD -- 2>/dev/null; then
        print_step "ğŸ’¾ Sauvegarde des changements locaux..."
        git stash push -m "Auto-stash avant mise Ã  jour $(date)"
        stashed=true
    else
        stashed=false
    fi

    # Git pull
    print_step "RÃ©cupÃ©ration des derniÃ¨res modifications..."
    git fetch origin
    git pull origin main || print_warning "Impossible de faire git pull"

    # VÃ©rifier si package.json a Ã©tÃ© modifiÃ©
    if git diff HEAD@{1} HEAD --name-only 2>/dev/null | grep -q "package.json"; then
        print_step "ğŸ“¦ package.json modifiÃ©, mise Ã  jour des dÃ©pendances..."
        npm install
    else
        print_step "Installation/mise Ã  jour des dÃ©pendances..."
        npm install
    fi

    # Restaurer les changements stashÃ©s si nÃ©cessaire
    if [ "$stashed" = true ]; then
        print_step "ğŸ”„ Restauration des changements locaux sauvegardÃ©s..."
        git stash pop
    fi

    # RedÃ©marrage
    print_step "RedÃ©marrage du bot..."
    pm2 restart pcr || pm2 start index.js --name pcr
    pm2 save

    # VÃ©rification finale
    sleep 5
    if check_app_status; then
        print_success "ğŸ‰ Mise Ã  jour terminÃ©e avec succÃ¨s!"
        print_success "Le bot PCR est en ligne"
    else
        print_error "âŒ ProblÃ¨me lors de la mise Ã  jour"
        echo "VÃ©rifiez les logs avec: pcr logs"
    fi
}

# Fonction de crÃ©ation de branche Git automatique
create_git_branch() {
    local branch_type="$1"  # "command" ou "event"
    local name="$2"
    local branch_name="feature/${branch_type}-${name}"
    
    # VÃ©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_warning "Pas dans un dÃ©pÃ´t Git - ignorer la crÃ©ation de branche"
        return 0
    fi
    
    # VÃ©rifier si on a des changements non committÃ©s
    if ! git diff-index --quiet HEAD --; then
        print_warning "Changements non committÃ©s dÃ©tectÃ©s"
        echo "Voulez-vous crÃ©er un commit avant de crÃ©er la nouvelle branche? (O/n): "
        read -n 1 stash_confirm
        echo ""
        if [[ "$stash_confirm" =~ ^[Oo]$ ]] || [[ -z "$stash_confirm" ]]; then
            git add -A
            git commit -m "Sauvegarde automatique avant crÃ©ation de branche $branch_name"
            print_success "Changements sauvegardÃ©s"
        else
            print_warning "CrÃ©ation de branche avec changements non committÃ©s"
        fi
    fi
    
    # VÃ©rifier si la branche existe dÃ©jÃ 
    if git show-ref --verify --quiet refs/heads/"$branch_name"; then
        print_warning "La branche '$branch_name' existe dÃ©jÃ "
        echo "Voulez-vous basculer sur cette branche? (O/n): "
        read -n 1 switch_confirm
        echo ""
        if [[ "$switch_confirm" =~ ^[Oo]$ ]] || [[ -z "$switch_confirm" ]]; then
            git checkout "$branch_name"
            print_success "BasculÃ© sur la branche existante '$branch_name'"
        fi
        return 0
    fi
    
    # CrÃ©er et basculer sur la nouvelle branche
    print_step "CrÃ©ation de la branche Git '$branch_name'..."
    if git checkout -b "$branch_name"; then
        print_success "Branche '$branch_name' crÃ©Ã©e et activÃ©e"
        return 0
    else
        print_error "Erreur lors de la crÃ©ation de la branche"
        return 1
    fi
}

# Fonction pour lister les branches de fonctionnalitÃ©s
list_feature_branches() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Pas dans un dÃ©pÃ´t Git"
        return 1
    fi
    
    print_section "Branches de fonctionnalitÃ©s PCR"
    
    # Lister les branches feature/command-* et feature/event-*
    local feature_branches
    feature_branches=$(git branch | grep -E "(feature/command-|feature/event-|fix/|feature/)" | sed 's/^[* ] //')
    
    if [[ -z "$feature_branches" ]]; then
        print_warning "Aucune branche de fonctionnalitÃ© trouvÃ©e"
        echo ""
        echo "ğŸ’¡ Pour crÃ©er une branche de fonctionnalitÃ©:"
        echo "  â€¢ pcr command --name <nom>    - Nouvelle commande"
        echo "  â€¢ pcr event --name <nom>      - Nouvel Ã©vÃ©nement"
        return 0
    fi
    
    echo "ğŸŒ¿ Branches disponibles:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
    local current_branch
    current_branch=$(git branch --show-current)
    
    while IFS= read -r branch; do
        local status_symbol=""
        local branch_info=""

        if [[ "$branch" == "$current_branch" ]]; then
            status_symbol="â¤ "
            branch_info=" (COURANTE)"
        else
            status_symbol="  "
        fi

        # Extraire le type et le nom
        if [[ "$branch" =~ feature/command-(.+) ]]; then
            local cmd_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}ğŸ”§ $branch${branch_info}"
            echo "    â””â”€ Commande: $cmd_name"
        elif [[ "$branch" =~ feature/event-(.+) ]]; then
            local event_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}âš¡ $branch${branch_info}"
            echo "    â””â”€ Ã‰vÃ©nement: $event_name"
        elif [[ "$branch" =~ fix/(.+) ]]; then
            local fix_name="${BASH_REMATCH[1]}"
            echo "${status_symbol}ğŸ› ï¸ $branch${branch_info}"
            echo "    â””â”€ Correction: $fix_name"
        else
            echo "${status_symbol}ğŸŒ¿ $branch${branch_info}"
        fi
        echo ""
    done <<< "$feature_branches"
    
    echo "ğŸ’¡ Commandes utiles:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "  â€¢ git checkout <branche>     - Basculer sur une branche"
    echo "  â€¢ git checkout main          - Revenir Ã  la branche principale"
    echo "  â€¢ git branch -d <branche>    - Supprimer une branche"
    echo "  â€¢ git push origin <branche>  - Pousser une branche"
}

# ===== SYSTÃˆME DE CHANGELOG ET RELEASE =====

# Fonction pour obtenir la version du projet depuis package.json
get_project_version() {
    if [[ -f "$PROJECT_DIR/package.json" ]]; then
        grep '"version"' "$PROJECT_DIR/package.json" | sed 's/.*"version": *"\([^"]*\)".*/\1/'
    else
        echo "1.0.0"
    fi
}

# Fonction pour ajouter une feature au changelog pending
add_pending_feature() {
    local type="$1"
    local name="$2"
    local description="$3"
    
    print_step "Ajout de la feature au changelog..."
    
    # CrÃ©er le script Node.js temporaire
    local temp_script="/tmp/pcr_add_feature_$$"
    cat > "$temp_script.js" << EOF
import { addPendingFeature } from '${PROJECT_DIR}/modules/version-manager.js';

try {
    const feature = addPendingFeature({
        type: '${type}',
        name: '${name}',
        description: '${description}'
    });
    
    if (feature) {
        console.log('âœ… Feature ajoutÃ©e au changelog');
    }
} catch (error) {
    console.error('âŒ Erreur:', error.message);
    process.exit(1);
}
EOF

    cd "$PROJECT_DIR"
    if node "$temp_script.js"; then
        rm -f "$temp_script.js"
        return 0
    else
        rm -f "$temp_script.js"
        print_warning "Impossible d'ajouter la feature au changelog"
        return 1
    fi
}

# Fonction pour crÃ©er une release
create_release() {
    local version_type="$1"  # patch, minor, major
    local title="$2"
    
    print_section "CrÃ©ation d'une nouvelle release"
    
    # VÃ©rifier qu'on est sur main
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
    
    if [[ "$current_branch" != "main" ]] && [[ "$current_branch" != "master" ]]; then
        echo "âš ï¸  Vous n'Ãªtes pas sur la branche principale (main/master)"
        echo "Branche actuelle: $current_branch"
        echo ""
        echo "âŒ Les releases doivent Ãªtre crÃ©Ã©es depuis la branche main."
        echo "ğŸ’¡ Utilisez 'git checkout main' pour basculer sur main."
        print_warning "Release annulÃ©e"
        return 1
    fi
    
    # CrÃ©er le script Node.js temporaire
    local temp_script="/tmp/pcr_release_$$"
    cat > "$temp_script.js" << EOF
import { createRelease, getChangelogStats, generateChangelogMarkdown } from '${PROJECT_DIR}/modules/version-manager.js';
import fs from 'fs';

try {
    // VÃ©rifier les features pending
    const stats = getChangelogStats();
    console.log(\`ğŸ“Š Features en attente: \${stats.pendingFeatures}\`);
    
    if (stats.pendingFeatures === 0) {
        console.log('âš ï¸  Aucune feature en attente pour la release');
        process.exit(1);
    }
    
    // CrÃ©er la release
    const release = createRelease('${version_type}', '${title}');
    
    // GÃ©nÃ©rer le changelog markdown
    const markdown = generateChangelogMarkdown();
    fs.writeFileSync('CHANGELOG.md', markdown);
    
    console.log(\`ğŸ‰ Release \${release.version} crÃ©Ã©e avec succÃ¨s!\`);
    console.log(\`ğŸ“‹ Features incluses: \${release.features.length}\`);
    console.log('ğŸ“ CHANGELOG.md gÃ©nÃ©rÃ©');
    
} catch (error) {
    console.error('âŒ Erreur:', error.message);
    process.exit(1);
}
EOF

    cd "$PROJECT_DIR"
    if node "$temp_script.js"; then
        rm -f "$temp_script.js"
        
        # Committer les changements
        print_step "Commit des fichiers de release..."
        git add changelog.json package.json CHANGELOG.md
        
        local new_version
        new_version=$(get_project_version)
        
        if git commit -m "chore: release v${new_version}

- Update version to ${new_version}
- Add changelog entries
- Generate CHANGELOG.md"; then
            
            print_success "âœ… Release v${new_version} commitÃ©e"
            
            # Proposer de crÃ©er un tag
            echo ""
            echo "ğŸ“Œ Voulez-vous crÃ©er un tag Git pour cette release? (O/n): "
            read -n 1 tag_confirm
            echo ""
            
            if [[ "$tag_confirm" =~ ^[Oo]$ ]] || [[ -z "$tag_confirm" ]]; then
                git tag -a "v${new_version}" -m "Release v${new_version}"
                print_success "ğŸ·ï¸  Tag v${new_version} crÃ©Ã©"
            fi
            
            # Proposer de push
            echo ""
            echo "ğŸš€ Voulez-vous pousser vers le dÃ©pÃ´t distant? (O/n): "
            read -n 1 push_confirm
            echo ""
            
            if [[ "$push_confirm" =~ ^[Oo]$ ]] || [[ -z "$push_confirm" ]]; then
                print_step "Push vers origin..."
                
                # S'assurer qu'on est bien sur main avant de push
                local push_branch
                push_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
                
                if [[ "$push_branch" != "main" ]] && [[ "$push_branch" != "master" ]]; then
                    print_error "Erreur: Tentative de push depuis $push_branch au lieu de main"
                    print_error "Basculez sur main avec: git checkout main"
                    return 1
                fi
                
                if git push origin "$push_branch"; then
                    if git tag -l "v${new_version}" >/dev/null 2>&1; then
                        git push origin "v${new_version}"
                        print_success "ğŸ·ï¸  Tag poussÃ© - GitHub Actions va se dÃ©clencher!"
                    fi
                    print_success "ğŸ‰ Release publiÃ©e avec succÃ¨s!"
                    echo ""
                    echo "ğŸŒ Actions automatiques dÃ©clenchÃ©es:"
                    echo "  â€¢ GitHub Actions Release workflow"
                    echo "  â€¢ Publication automatique du changelog"
                    echo "  â€¢ Notification Discord (si configurÃ©e)"
                else
                    print_warning "Erreur lors du push"
                fi
            fi
        else
            print_error "Erreur lors du commit de release"
            rm -f "$temp_script.js"
            return 1
        fi
    else
        rm -f "$temp_script.js"
        return 1
    fi
}

# Fonction pour finaliser une feature (commit + push + merge)
finalize_feature() {
    local branch_name
    branch_name=$(git branch --show-current 2>/dev/null)
    
    if [[ -z "$branch_name" ]]; then
        print_error "Impossible de dÃ©terminer la branche actuelle"
        return 1
    fi
    
    if [[ "$branch_name" == "main" ]] || [[ "$branch_name" == "master" ]]; then
        print_error "Vous Ãªtes dÃ©jÃ  sur la branche principale"
        echo "ğŸ’¡ Cette commande est pour finaliser une feature branch"
        return 1
    fi
    
    print_section "Finalisation de la feature: $branch_name"
    
    # DÃ©tecter le type et le nom de la feature
    local feature_type=""
    local feature_name=""
    local feature_description=""
    
    if [[ "$branch_name" =~ feature/command-(.+) ]]; then
        feature_type="command"
        feature_name="${BASH_REMATCH[1]}"
        feature_description="Nouvelle commande Discord: /${feature_name}"
    elif [[ "$branch_name" =~ feature/event-(.+) ]]; then
        feature_type="event"
        feature_name="${BASH_REMATCH[1]}"
        feature_description="Nouvel Ã©vÃ©nement Discord: ${feature_name}"
    else
        feature_type="feature"
        feature_name="$branch_name"
        feature_description="Nouvelle fonctionnalitÃ©: $branch_name"
    fi
    
    echo "ğŸ” Feature dÃ©tectÃ©e:"
    echo "  â€¢ Type: $feature_type"
    echo "  â€¢ Nom: $feature_name"
    echo "  â€¢ Description: $feature_description"
    echo ""
    
    # Demander confirmation
    echo "Voulez-vous finaliser cette feature? (O/n): "
    read -n 1 confirm
    echo ""
    
    if [[ ! "$confirm" =~ ^[Oo]$ ]] && [[ -n "$confirm" ]]; then
        print_warning "Finalisation annulÃ©e"
        return 1
    fi
    
    # 1. Commit des changements restants
    if ! git diff --quiet || ! git diff --cached --quiet; then
        print_step "Commit des derniers changements..."
        git add .
        git commit -m "feat: finalize $feature_type '$feature_name'

- Complete implementation of $feature_name
- Ready for merge to main" || {
            print_warning "Aucun changement Ã  committer ou erreur de commit"
        }
    fi
    
    # 2. Push de la branche
    print_step "Push de la branche vers origin..."
    if git push -u origin "$branch_name"; then
        print_success "âœ… Branche poussÃ©e vers origin"
    else
        print_warning "Erreur lors du push - continuons quand mÃªme"
    fi
    
    # 3. Ajouter au changelog pending
    print_step "Ajout au changelog..."
    add_pending_feature "$feature_type" "$feature_name" "$feature_description"
    
    # 4. Merger vers main
    print_step "Merge vers main..."
    
    # RÃ©cupÃ©rer les derniÃ¨res modifications de main
    git fetch origin main 2>/dev/null || true
    
    # Basculer sur main
    git checkout main
    git pull origin main 2>/dev/null || true
    
    # Merger la feature
    if git merge --no-ff "$branch_name" -m "feat: merge $feature_type '$feature_name'

- Merged feature branch: $branch_name
- Added to changelog pending list"; then
        
        print_success "âœ… Feature mergÃ©e vers main"
        
        # 5. Push main
        print_step "Push de main..."
        if git push origin main; then
            print_success "âœ… Main poussÃ© vers origin"
            
            # 6. Nettoyer la branche
            echo ""
            echo "ğŸ§¹ Voulez-vous supprimer la branche feature locale? (O/n): "
            read -n 1 delete_confirm
            echo ""
            
            if [[ "$delete_confirm" =~ ^[Oo]$ ]] || [[ -z "$delete_confirm" ]]; then
                git branch -d "$branch_name"
                print_success "ğŸ—‘ï¸  Branche locale supprimÃ©e"
                
                echo "Voulez-vous aussi supprimer la branche distante? (o/N): "
                read -n 1 delete_remote_confirm
                echo ""
                
                if [[ "$delete_remote_confirm" =~ ^[Oo]$ ]]; then
                    git push origin --delete "$branch_name"
                    print_success "ğŸ—‘ï¸  Branche distante supprimÃ©e"
                fi
            fi
            
            # 7. Proposer de crÃ©er une release
            echo ""
            echo "ğŸ¯ Feature finalisÃ©e avec succÃ¨s!"
            echo ""
            echo "ğŸš€ Voulez-vous crÃ©er une release maintenant? (o/N): "
            read -n 1 release_confirm
            echo ""
            
            if [[ "$release_confirm" =~ ^[Oo]$ ]]; then
                # VÃ©rifier qu'on est bien sur main
                local current_release_branch
                current_release_branch=$(git branch --show-current 2>/dev/null)
                
                if [[ "$current_release_branch" != "main" ]] && [[ "$current_release_branch" != "master" ]]; then
                    echo "ğŸ”„ Basculement sur main pour crÃ©er la release..."
                    git checkout main
                fi
                
                echo "Type de release (patch/minor/major) [patch]: "
                read version_type
                version_type=${version_type:-patch}
                
                create_release "$version_type" "Release avec $feature_name"
            else
                echo "ğŸ’¡ Pour crÃ©er une release plus tard:"
                echo "   pcr release --type patch"
            fi
            
        else
            print_error "Erreur lors du push de main"
            return 1
        fi
    else
        print_error "Erreur lors du merge"
        echo "ğŸ’¡ RÃ©solvez les conflits manuellement puis rÃ©essayez"
        return 1
    fi
}

# Fonction de commit automatique aprÃ¨s crÃ©ation
auto_commit_and_push() {
    local type="$1"      # "command" ou "event"
    local name="$2"
    local file_path="$3"
    local description="$4"  # Description optionnelle
    local branch_name="feature/${type}-${name}"
    
    # VÃ©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        return 0
    fi
    
    print_step "Commit automatique du nouveau $type '$name'..."
    
    # Ajouter le fichier crÃ©Ã©
    git add "$file_path"
    
    # CrÃ©er le message de commit
    local commit_msg
    if [[ "$type" == "command" ]]; then
        commit_msg="feat: add new Discord command '$name'

- Generated using 'pcr command --name $name'
- File: $(basename "$file_path")
- Ready for implementation"
    else
        commit_msg="feat: add new Discord event '$name'

- Generated using 'pcr event --name $name' 
- File: $(basename "$file_path")
- Ready for implementation"
    fi
    
    # Effectuer le commit
    if git commit -m "$commit_msg"; then
        print_success "Commit effectuÃ© avec succÃ¨s"
        
        # Demander si on veut push
        echo ""
        echo "Voulez-vous pousser la branche vers le dÃ©pÃ´t distant? (O/n): "
        read -n 1 push_confirm
        echo ""
        if [[ "$push_confirm" =~ ^[Oo]$ ]] || [[ -z "$push_confirm" ]]; then
            print_step "Push de la branche '$branch_name'..."
            if git push -u origin "$branch_name"; then
                print_success "Branche poussÃ©e vers origin/$branch_name"
                echo ""
                echo "ğŸŒ Actions suggÃ©rÃ©es:"
                echo "  â€¢ CrÃ©er une Pull Request sur GitHub/GitLab"
                echo "  â€¢ Continuer le dÃ©veloppement sur cette branche"
                echo "  â€¢ Merger quand prÃªt: git checkout main && git merge $branch_name"
                echo ""
                print_success "âœ… Feature crÃ©Ã©e et prÃªte pour le dÃ©veloppement"
                echo "ğŸ’¡ Utilisez 'pcr finish' quand vous aurez terminÃ© le dÃ©veloppement"
                
            else
                print_warning "Erreur lors du push - vous pouvez le faire manuellement plus tard"
                echo "  Commande: git push -u origin $branch_name"
            fi
        else
            print_success "Branche crÃ©Ã©e localement (non poussÃ©e)"
            echo ""
            echo "ğŸ’¡ Pour pousser plus tard:"
            echo "  git push -u origin $branch_name"
            echo ""
            print_success "âœ… Feature crÃ©Ã©e et prÃªte pour le dÃ©veloppement"
            echo "ğŸ’¡ Utilisez 'pcr finish' quand vous aurez terminÃ© le dÃ©veloppement"
        fi
    else
        print_error "Erreur lors du commit"
        return 1
    fi
}

# Fonction pour publier un changelog manuel
publish_manual_changelog() {
    local version="$1"
    local title="$2"
    
    print_step "Analyse des commits rÃ©cents pour le changelog..."
    
    # RÃ©cupÃ©rer les commits depuis le dernier tag ou les 10 derniers
    local last_tag
    last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
    
    local commits_range
    if [[ -n "$last_tag" ]]; then
        commits_range="${last_tag}..HEAD"
        echo "ğŸ“ Analyse depuis le tag: $last_tag"
    else
        commits_range="HEAD~10..HEAD"
        echo "ğŸ“ Analyse des 10 derniers commits"
    fi
    
    # Analyser les commits pour extraire les fonctionnalitÃ©s
    local features_json="/tmp/pcr_features_$$"
    cat > "${features_json}.js" << EOF
import { Client, GatewayIntentBits } from 'discord.js';
import { announceChangelog } from '${PROJECT_DIR}/modules/changelog.js';
import dotenv from 'dotenv';
import { execSync } from 'child_process';
dotenv.config();

const client = new Client({
    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]
});

client.once('ready', async () => {
    console.log('ğŸ¤– Bot connectÃ© pour le changelog...');
    
    try {
        // RÃ©cupÃ©rer les commits
        const commits = execSync('git log ${commits_range} --oneline --grep="feat:" || true', {
            cwd: '${PROJECT_DIR}',
            encoding: 'utf8'
        }).trim().split('\n').filter(line => line.length > 0);
        
        const features = [];
        
        commits.forEach(commit => {
            const match = commit.match(/feat: add new Discord (command|event) '([^']+)'/);
            if (match) {
                const [, type, name] = match;
                features.push({
                    type: type,
                    name: name,
                    description: \`Nouvelle fonctionnalitÃ©: \${name}\`
                });
            } else if (commit.includes('feat:')) {
                // Autres types de fonctionnalitÃ©s
                const name = commit.split(' ').slice(1).join(' ').replace(/^feat: /, '');
                features.push({
                    type: 'feature',
                    name: name.substring(0, 50) + (name.length > 50 ? '...' : ''),
                    description: name
                });
            }
        });
        
        if (features.length === 0) {
            console.log('âš ï¸  Aucune nouvelle fonctionnalitÃ© trouvÃ©e dans les commits rÃ©cents');
            process.exit(0);
        }
        
        await announceChangelog(client, {
            version: '${version}',
            title: '${title:-Changelog PCR Bot}',
            features: features
        });
        
        console.log(\`âœ… Changelog publiÃ© avec \${features.length} fonctionnalitÃ©(s)\`);
    } catch (error) {
        console.error('âŒ Erreur lors du changelog:', error.message);
    }
    
    process.exit(0);
});

client.login(process.env.DISCORD_TOKEN).catch(error => {
    console.error('âŒ Erreur de connexion Discord:', error.message);
    console.log('âš ï¸  Assurez-vous que DISCORD_TOKEN est configurÃ© dans .env');
    process.exit(1);
});
EOF

    # VÃ©rifier si le bot peut se connecter
    if [[ -f "$PROJECT_DIR/.env" ]] && grep -q "DISCORD_TOKEN=" "$PROJECT_DIR/.env"; then
        echo ""
        echo "ğŸ“Š FonctionnalitÃ©s dÃ©tectÃ©es depuis les commits rÃ©cents:"
        git log $commits_range --oneline --grep="feat:" | head -5 || echo "Aucune fonctionnalitÃ© dÃ©tectÃ©e"
        echo ""
        echo "ğŸ“¢ Voulez-vous publier le changelog version $version? (O/n): "
        read -n 1 publish_confirm
        echo ""
        
        if [[ "$publish_confirm" =~ ^[Oo]$ ]] || [[ -z "$publish_confirm" ]]; then
            cd "$PROJECT_DIR"
            timeout 30s node "${features_json}.js" 2>/dev/null || {
                print_warning "Impossible de publier le changelog automatiquement"
                echo "ğŸ’¡ VÃ©rifiez la configuration Discord et rÃ©essayez"
            }
        fi
    else
        print_warning "Token Discord non configurÃ©"
        echo "ğŸ’¡ Configurez DISCORD_TOKEN dans .env pour publier des changelogs"
    fi
    
    # Nettoyer le fichier temporaire
    rm -f "${features_json}.js"
}

# Fonction de crÃ©ation d'Ã©vÃ©nement
create_event() {
    local event_name="$1"
    
    if [[ -z "$event_name" ]]; then
        print_error "Nom d'Ã©vÃ©nement requis"
        echo "Usage: pcr event --name <nom_evenement>"
        echo "Exemple: pcr event --name messageUpdate"
        return 1
    fi
    
    # CrÃ©er la branche Git automatiquement
    create_git_branch "event" "$event_name"
    
    # VÃ©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$event_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom d'Ã©vÃ©nement invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local events_dir="$PROJECT_DIR/events/client"
    local example_file="$events_dir/example"
    local new_event_file="$events_dir/$event_name.js"
    
    # VÃ©rifier si le fichier example existe
    if [[ ! -f "$example_file" ]]; then
        print_error "Fichier template non trouvÃ©: $example_file"
        return 1
    fi
    
    # VÃ©rifier si l'Ã©vÃ©nement existe dÃ©jÃ 
    if [[ -f "$new_event_file" ]]; then
        print_error "L'Ã©vÃ©nement '$event_name' existe dÃ©jÃ "
        print_warning "Fichier existant: $new_event_file"
        return 1
    fi
    
    print_step "CrÃ©ation de l'Ã©vÃ©nement '$event_name'..."
    
    # Copier le template et remplacer les valeurs par dÃ©faut
    cp "$example_file" "$new_event_file"
    
    # Remplacer 'name' par le nom de l'Ã©vÃ©nement
    sed -i "s/const name = 'name'/const name = '$event_name'/g" "$new_event_file"
    
    # Ajouter un commentaire d'identification
    sed -i "1i// Ã‰vÃ©nement: $event_name" "$new_event_file"
    sed -i "2i//" "$new_event_file"
    
    print_success "Ã‰vÃ©nement '$event_name' crÃ©Ã© avec succÃ¨s!"
    print_success "Fichier: $new_event_file"
    
    # Commit automatique et push
    auto_commit_and_push "event" "$event_name" "$new_event_file" "Nouvel Ã©vÃ©nement Discord pour gÃ©rer $event_name"
    
    echo ""
    echo "ğŸ“ Prochaines Ã©tapes:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "  1. Ã‰ditez le fichier pour personnaliser l'Ã©vÃ©nement"
    echo "  2. Modifiez la propriÃ©tÃ© 'once' (true/false)"
    echo "  3. ImplÃ©mentez la logique dans la fonction execute"
    echo "  4. RedÃ©marrez le bot: pcr restart"
    echo ""
    echo "ğŸ’¡ Commandes utiles:"
    echo "  â€¢ Ã‰diter: nano $new_event_file"
    echo "  â€¢ Voir les logs: pcr logs"
    echo ""
    echo "ğŸŒ¿ Git workflow:"
    echo "  â€¢ Branche courante: feature/event-$event_name"
    echo "  â€¢ Quand prÃªt: pcr finish"
    echo "  â€¢ Revenir Ã  main: git checkout main"
    echo ""
    echo "ğŸ“š Ã‰vÃ©nements Discord courants:"
    echo "  â€¢ ready, messageCreate, messageDelete"
    echo "  â€¢ guildMemberAdd, guildMemberRemove"
    echo "  â€¢ interactionCreate, messageReactionAdd"
}

# Fonction de crÃ©ation de commande
create_command() {
    local command_name="$1"
    local command_desc="$2"
    
    if [[ -z "$command_name" ]]; then
        print_error "Nom de commande requis"
        echo "Usage: pcr command --name <nom_commande> [--desc <description>]"
        echo "Exemple: pcr command --name hello"
        echo "Exemple: pcr command --name hello --desc \"Commande de salutation\""
        return 1
    fi
    
    # CrÃ©er la branche Git automatiquement
    create_git_branch "command" "$command_name"
    
    # VÃ©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$command_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom de commande invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local commands_dir="$PROJECT_DIR/commands"
    local example_file="$commands_dir/example"
    local new_command_file="$commands_dir/$command_name.js"
    
    # VÃ©rifier si le fichier example existe
    if [[ ! -f "$example_file" ]]; then
        print_error "Fichier template non trouvÃ©: $example_file"
        return 1
    fi
    
    # VÃ©rifier si la commande existe dÃ©jÃ 
    if [[ -f "$new_command_file" ]]; then
        print_error "La commande '$command_name' existe dÃ©jÃ "
        print_warning "Fichier existant: $new_command_file"
        return 1
    fi
    
    print_step "CrÃ©ation de la commande '$command_name'..."
    
    # Copier le template et remplacer les valeurs par dÃ©faut
    cp "$example_file" "$new_command_file"
    
    # Remplacer 'name' par le nom de la commande
    sed -i "s/\.setName('name')/\.setName('$command_name')/g" "$new_command_file"
    
    # Remplacer 'Description' par une description personnalisÃ©e
    if [[ -n "$command_desc" ]]; then
        # Utiliser la description fournie
        sed -i "s/\.setDescription('Description')/\.setDescription('$command_desc')/g" "$new_command_file"
    else
        # Utiliser une description par dÃ©faut
        sed -i "s/\.setDescription('Description')/\.setDescription('Description de la commande $command_name')/g" "$new_command_file"
    fi
    
    print_success "Commande '$command_name' crÃ©Ã©e avec succÃ¨s!"
    print_success "Fichier: $new_command_file"
    
    # Commit automatique et push
    local desc_for_changelog="${command_desc:-Nouvelle commande Discord: $command_name}"
    auto_commit_and_push "command" "$command_name" "$new_command_file" "$desc_for_changelog"
    
    echo ""
    echo "ğŸ“ Prochaines Ã©tapes:"
    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    echo "  1. Ã‰ditez le fichier pour personnaliser la commande"
    echo "  2. Modifiez la description et les options"
    echo "  3. ImplÃ©mentez la logique dans la fonction execute"
    echo "  4. RedÃ©marrez le bot: pcr restart"
    echo ""
    echo "ğŸ’¡ Commandes utiles:"
    echo "  â€¢ Ã‰diter: nano $new_command_file"
    echo "  â€¢ Voir les logs: pcr logs"
    echo ""
    echo "ğŸŒ¿ Git workflow:"
    echo "  â€¢ Branche courante: feature/command-$command_name"
    echo "  â€¢ Quand prÃªt: pcr finish"
    echo "  â€¢ Revenir Ã  main: git checkout main"
}

# Fonction de crÃ©ation de feature branch (nouvelle)
create_feature_branch() {
    local feature_name="$1"
    
    if [[ -z "$feature_name" ]]; then
        print_error "Nom de feature requis"
        echo "Usage: pcr feature <nom_feature>"
        echo "Exemple: pcr feature user-profile-system"
        return 1
    fi
    
    # VÃ©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$feature_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom de feature invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local branch_name="feature/$feature_name"
    
    print_section "CrÃ©ation de la feature branch '$feature_name'"
    
    # VÃ©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Pas dans un dÃ©pÃ´t Git"
        return 1
    fi
    
    # VÃ©rifier si la branche existe dÃ©jÃ 
    if git show-ref --verify --quiet refs/heads/"$branch_name"; then
        print_warning "La branche '$branch_name' existe dÃ©jÃ "
        echo "Voulez-vous basculer sur cette branche? (O/n): "
        read -n 1 switch_confirm
        echo ""
        if [[ "$switch_confirm" =~ ^[Oo]$ ]] || [[ -z "$switch_confirm" ]]; then
            git checkout "$branch_name"
            print_success "BasculÃ© sur la branche existante '$branch_name'"
        fi
        return 0
    fi
    
    # VÃ©rifier si on a des changements non committÃ©s
    if ! git diff-index --quiet HEAD --; then
        print_warning "Changements non committÃ©s dÃ©tectÃ©s"
        echo "Voulez-vous crÃ©er un commit avant de crÃ©er la nouvelle branche? (O/n): "
        read -n 1 stash_confirm
        echo ""
        if [[ "$stash_confirm" =~ ^[Oo]$ ]] || [[ -z "$stash_confirm" ]]; then
            git add -A
            git commit -m "WIP: sauvegarde automatique avant feature $feature_name"
            print_success "Changements sauvegardÃ©s"
        fi
    fi
    
    # S'assurer qu'on est sur main et Ã  jour
    print_step "Mise Ã  jour de la branche main..."
    git checkout main 2>/dev/null || git checkout master 2>/dev/null
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true
    
    # CrÃ©er et basculer sur la nouvelle branche
    print_step "CrÃ©ation de la branche feature '$branch_name'..."
    if git checkout -b "$branch_name"; then
        print_success "âœ… Branche '$branch_name' crÃ©Ã©e et activÃ©e"
        echo ""
        echo "ğŸŒ¿ Feature branch crÃ©Ã©e:"
        echo "  â€¢ Nom: $branch_name"
        echo "  â€¢ Base: main"
        echo "  â€¢ Statut: PrÃªt pour le dÃ©veloppement"
        echo ""
        echo "ğŸ’¡ Prochaines Ã©tapes:"
        echo "  â€¢ DÃ©veloppez votre feature"
        echo "  â€¢ Committez vos changements: git add . && git commit -m 'feat: ...'"
        echo "  â€¢ Pushez quand prÃªt: git push -u origin $branch_name"
        echo "  â€¢ Finalisez avec: pcr finish"
        echo ""
        return 0
    else
        print_error "Erreur lors de la crÃ©ation de la branche"
        return 1
    fi
}

# Fonction de crÃ©ation de fix branch (nouvelle)
create_fix_branch() {
    local fix_name="$1"
    
    if [[ -z "$fix_name" ]]; then
        print_error "Nom de fix requis"
        echo "Usage: pcr fix <nom_fix>"
        echo "Exemple: pcr fix login-validation-error"
        return 1
    fi
    
    # VÃ©rifier que le nom est valide (alphanumeric + tirets)
    if [[ ! "$fix_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Nom de fix invalide. Utilisez uniquement des lettres, chiffres, tirets et underscores."
        return 1
    fi
    
    local branch_name="fix/$fix_name"
    
    print_section "CrÃ©ation de la fix branch '$fix_name'"
    
    # VÃ©rifier si on est dans un repo Git
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Pas dans un dÃ©pÃ´t Git"
        return 1
    fi
    
    # VÃ©rifier si la branche existe dÃ©jÃ 
    if git show-ref --verify --quiet refs/heads/"$branch_name"; then
        print_warning "La branche '$branch_name' existe dÃ©jÃ "
        echo "Voulez-vous basculer sur cette branche? (O/n): "
        read -n 1 switch_confirm
        echo ""
        if [[ "$switch_confirm" =~ ^[Oo]$ ]] || [[ -z "$switch_confirm" ]]; then
            git checkout "$branch_name"
            print_success "BasculÃ© sur la branche existante '$branch_name'"
        fi
        return 0
    fi
    
    # VÃ©rifier si on a des changements non committÃ©s
    if ! git diff-index --quiet HEAD --; then
        print_warning "Changements non committÃ©s dÃ©tectÃ©s"
        echo "Voulez-vous crÃ©er un commit avant de crÃ©er la nouvelle branche? (O/n): "
        read -n 1 stash_confirm
        echo ""
        if [[ "$stash_confirm" =~ ^[Oo]$ ]] || [[ -z "$stash_confirm" ]]; then
            git add -A
            git commit -m "WIP: sauvegarde automatique avant fix $fix_name"
            print_success "Changements sauvegardÃ©s"
        fi
    fi
    
    # S'assurer qu'on est sur main et Ã  jour
    print_step "Mise Ã  jour de la branche main..."
    git checkout main 2>/dev/null || git checkout master 2>/dev/null
    git pull origin main 2>/dev/null || git pull origin master 2>/dev/null || true
    
    # CrÃ©er et basculer sur la nouvelle branche
    print_step "CrÃ©ation de la branche fix '$branch_name'..."
    if git checkout -b "$branch_name"; then
        print_success "âœ… Branche '$branch_name' crÃ©Ã©e et activÃ©e"
        echo ""
        echo "ğŸ”§ Fix branch crÃ©Ã©e:"
        echo "  â€¢ Nom: $branch_name"
        echo "  â€¢ Base: main"  
        echo "  â€¢ Type: Correction de bug"
        echo "  â€¢ Statut: PrÃªt pour le dÃ©veloppement"
        echo ""
        echo "ğŸ’¡ Prochaines Ã©tapes:"
        echo "  â€¢ Corrigez le problÃ¨me"
        echo "  â€¢ Committez vos changements: git add . && git commit -m 'fix: ...'"
        echo "  â€¢ Pushez quand prÃªt: git push -u origin $branch_name"
        echo "  â€¢ Mergez directement (les fixes ne vont pas dans le changelog)"
        echo ""
        echo "âš ï¸  Note: Les fixes ne sont pas ajoutÃ©s au changelog automatiquement"
        echo ""
        return 0
    else
        print_error "Erreur lors de la crÃ©ation de la branche"
        return 1
    fi
}

# Fonction d'installation du script dans le PATH
install_script() {
    local script_path="/usr/local/bin/pcr"
    
    if [[ -f "$script_path" ]]; then
        echo -n "Le script est dÃ©jÃ  installÃ©. Voulez-vous le mettre Ã  jour? (O/n): "
        read -n 1 confirmation
        echo ""
        if [[ ! "$confirmation" =~ ^[Oo]$ ]] && [[ -n "$confirmation" ]]; then
            print_warning "Installation annulÃ©e"
            return 1
        fi
    fi
    
    print_step "Installation du script pcr dans /usr/local/bin..."
    
    # Copier le script
    if sudo cp "$PROJECT_DIR/pcr" "$script_path"; then
        sudo chmod +x "$script_path"
        print_success "Script installÃ© avec succÃ¨s!"
        print_success "Vous pouvez maintenant utiliser 'pcr' depuis n'importe oÃ¹"
        echo ""
        echo "ğŸ’¡ Conseils:"
        echo "  - Utilisez 'pcr' depuis le rÃ©pertoire du projet ou ses sous-rÃ©pertoires"
        echo "  - Le script dÃ©tectera automatiquement le bon rÃ©pertoire de projet"
        echo "  - Pour dÃ©sinstaller: sudo rm /usr/local/bin/pcr"
    else
        print_error "Erreur lors de l'installation (permissions sudo requises)"
        return 1
    fi
}

case "$1" in
    dev)
        validate_project_directory
        echo "ğŸš€ Lancement du mode dÃ©veloppement..."
        echo ""
        print_step "DÃ©marrage du bot en mode dÃ©veloppement..."
        cd "$PROJECT_DIR"
        npm run dev
        ;;
    start)
        validate_project_directory
        print_section "DÃ©marrage du Bot PCR"
        cd "$PROJECT_DIR"
        pm2 start index.js --name pcr 2>/dev/null || {
            print_warning "Processus dÃ©jÃ  en cours, tentative de redÃ©marrage..."
            pm2 restart pcr
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "ğŸ‰ Bot PCR dÃ©marrÃ© avec succÃ¨s!"
            echo ""
            echo "ğŸ“Š Informations du bot:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸ¤– Nom: PCR Discord Bot"
            echo "ğŸ“ RÃ©pertoire: $PROJECT_DIR"
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "  â€¢ pcr status   - VÃ©rifier l'Ã©tat"
            echo "  â€¢ pcr logs     - Voir les logs"
            echo "  â€¢ pcr monitor  - Monitoring complet"
        else
            print_error "âŒ Ã‰chec du dÃ©marrage"
            echo ""
            echo "ğŸ” VÃ©rifications suggÃ©rÃ©es:"
            echo "  â€¢ VÃ©rifiez les logs: pcr logs"
            echo "  â€¢ VÃ©rifiez les permissions"
            echo "  â€¢ RedÃ©marrez: pcr restart"
        fi
        ;;
    stop)
        print_section "ArrÃªt du Bot PCR"
        pm2 stop pcr 2>/dev/null || print_warning "Bot dÃ©jÃ  arrÃªtÃ©"
        echo ""
        print_success "ğŸ›‘ Bot PCR arrÃªtÃ© avec succÃ¨s"
        echo ""
        echo "ğŸ’¡ Pour redÃ©marrer:"
        echo "  â€¢ pcr start    - DÃ©marrer le bot"
        echo "  â€¢ pcr restart  - RedÃ©marrer directement"
        ;;
    restart)
        print_section "RedÃ©marrage du Bot PCR"
        cd "$PROJECT_DIR"
        pm2 restart pcr 2>/dev/null || {
            print_warning "Processus non trouvÃ©, dÃ©marrage..."
            pm2 start index.js --name pcr
        }
        pm2 save
        sleep 2
        echo ""
        if check_app_status; then
            print_success "ğŸ”„ Bot PCR redÃ©marrÃ© avec succÃ¨s!"
            echo ""
            echo "ğŸ“Š Informations du bot:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸ¤– Nom: PCR Discord Bot"
            echo "ğŸ“ RÃ©pertoire: $PROJECT_DIR"
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "  â€¢ pcr logs     - Voir les logs"
            echo "  â€¢ pcr monitor  - Monitoring complet"
        else
            print_error "âŒ Ã‰chec du redÃ©marrage"
            echo ""
            echo "ğŸ” VÃ©rifications suggÃ©rÃ©es:"
            echo "  â€¢ VÃ©rifiez les logs: pcr logs"
            echo "  â€¢ Essayez un arrÃªt/dÃ©marrage: pcr stop && pcr start"
        fi
        ;;
    status)
        print_section "Statut du Bot PCR"
        if check_app_status; then
            print_success "ğŸŸ¢ Bot PCR en ligne"
            echo ""
            echo "ğŸ“Š Informations rapides:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "ğŸ¤– Processus PM2: Actif"
            echo "ğŸ“ RÃ©pertoire: $PROJECT_DIR"
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "  â€¢ pcr logs     - Voir les logs en temps rÃ©el"
            echo "  â€¢ pcr monitor  - Monitoring dÃ©taillÃ©"
        else
            print_error "ğŸ”´ Bot PCR hors ligne"
            echo ""
            echo "ğŸ” Actions suggÃ©rÃ©es:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ pcr start    - DÃ©marrer le bot"
            echo "  â€¢ pcr logs     - VÃ©rifier les erreurs"
            echo "  â€¢ pcr deploy   - RedÃ©ployer si nÃ©cessaire"
        fi
        ;;
    logs)
        print_section "Logs du Bot PCR"
        echo "ğŸ“‹ Affichage en temps rÃ©el (Ctrl+C pour arrÃªter)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        pm2 logs pcr 2>/dev/null || {
            print_error "Impossible d'accÃ©der aux logs"
            echo ""
            echo "ğŸ” VÃ©rifications:"
            echo "  â€¢ Le bot est-il dÃ©marrÃ©? pcr status"
            echo "  â€¢ Essayez de redÃ©marrer: pcr restart"
        }
        ;;
    monitor)
        monitor_function
        ;;
    update)
        update_function
        ;;
    deploy)
        echo "ğŸš€ DÃ©ploiement du bot PCR..."
        cd "$PROJECT_DIR"
        
        # Sauvegarde automatique avant dÃ©ploiement
        print_step "Sauvegarde automatique avant dÃ©ploiement..."
        backup_database || echo "Continuer sans sauvegarde..."
        
        # VÃ©rification et crÃ©ation du fichier .env
        print_step "VÃ©rification de la configuration d'environnement..."
        if [ ! -f ".env" ]; then
            if [ -f ".env.example" ]; then
                print_step "Copie de .env.example vers .env..."
                cp .env.example .env
                print_success "Fichier .env crÃ©Ã© Ã  partir de .env.example"
                print_warning "N'oubliez pas de configurer vos tokens dans .env"
            else
                print_warning "Ni .env ni .env.example trouvÃ©s"
                print_warning "Assurez-vous d'avoir configurÃ© vos variables d'environnement"
            fi
        else
            print_success "Fichier .env dÃ©jÃ  prÃ©sent"
        fi
        
        # ArrÃªt de l'application
        print_step "ArrÃªt du bot si il est en cours d'exÃ©cution..."
        pm2 stop pcr 2>/dev/null || echo "Bot pas encore dÃ©marrÃ©"

        # Installation des dÃ©pendances
        print_step "Installation des dÃ©pendances..."
        npm install

        # DÃ©marrage du bot avec PM2
        print_step "DÃ©marrage du bot avec PM2..."
        pm2 start index.js --name pcr

        # Sauvegarde de la configuration PM2
        print_step "Sauvegarde de la configuration PM2..."
        pm2 save

        # VÃ©rification finale
        sleep 5
        if check_app_status; then
            print_success "ğŸ‰ DÃ©ploiement terminÃ© avec succÃ¨s!"
            print_success "Bot PCR Discord en ligne"
        else
            print_error "âŒ ProblÃ¨me lors du dÃ©ploiement"
        fi
        ;;
    event)
        # Gestion des options pour la commande event
        validate_project_directory
        
        # Parser les arguments
        event_name=""
        no_git=false
        
        # Analyser les paramÃ¨tres
        shift # Enlever 'event'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --name)
                    event_name="$2"
                    shift 2
                    ;;
                --no-git)
                    no_git=true
                    shift
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr event --name <nom_evenement> [--no-git]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$event_name" ]]; then
            if [[ "$no_git" == true ]]; then
                # Sauvegarder les fonctions Git temporairement
                create_git_branch() { return 0; }
                auto_commit_and_push() { return 0; }
            fi
            create_event "$event_name"
        else
            print_error "Usage: pcr event --name <nom_evenement> [--no-git]"
            echo "Exemple: pcr event --name messageUpdate"
            echo "Options:"
            echo "  --no-git    Skip Git branch creation and commit"
            echo ""
            echo "Cette commande crÃ©e un nouvel Ã©vÃ©nement Discord en utilisant"
            echo "le template du fichier 'example' dans le dossier events/client/"
            echo ""
            echo "ğŸ“š Ã‰vÃ©nements Discord courants:"
            echo "  â€¢ ready, messageCreate, messageDelete, messageUpdate"
            echo "  â€¢ guildMemberAdd, guildMemberRemove, guildMemberUpdate"
            echo "  â€¢ interactionCreate, messageReactionAdd, messageReactionRemove"
        fi
        ;;
    command)
        # Gestion des options pour la commande command
        validate_project_directory
        
        # Parser les arguments
        command_name=""
        command_desc=""
        no_git=false
        
        # Analyser les paramÃ¨tres
        shift # Enlever 'command'
        while [[ $# -gt 0 ]]; do
            case $1 in
                --name)
                    command_name="$2"
                    shift 2
                    ;;
                --desc)
                    command_desc="$2"
                    shift 2
                    ;;
                --no-git)
                    no_git=true
                    shift
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr command --name <nom_commande> [--desc <description>] [--no-git]"
                    exit 1
                    ;;
            esac
        done
        
        if [[ -n "$command_name" ]]; then
            if [[ "$no_git" == true ]]; then
                # Sauvegarder les fonctions Git temporairement
                create_git_branch() { return 0; }
                auto_commit_and_push() { return 0; }
            fi
            create_command "$command_name" "$command_desc"
        else
            print_error "Usage: pcr command --name <nom_commande> [--desc <description>] [--no-git]"
            echo "Exemple: pcr command --name hello"
            echo "Exemple: pcr command --name hello --desc \"Commande de salutation\""
            echo "Options:"
            echo "  --no-git    Skip Git branch creation and commit"
            echo ""
            echo "Cette commande crÃ©e une nouvelle commande Discord en utilisant"
            echo "le template du fichier 'example' dans le dossier commands/"
        fi
        ;;
    branches)
        validate_project_directory
        list_feature_branches
        ;;
    feature)
        validate_project_directory
        if [[ -n "$2" ]]; then
            create_feature_branch "$2"
        else
            print_error "Usage: pcr feature <nom_feature>"
            echo "Exemple: pcr feature user-profile-system"
            echo ""
            echo "Cette commande crÃ©e une nouvelle branche feature/<nom_feature>"
            echo "depuis main, sans toucher aux fichiers de changelog."
            echo ""
            echo "ğŸ’¡ DiffÃ©rence avec 'pcr command' et 'pcr event':"
            echo "  â€¢ pcr feature : CrÃ©e juste la branche Git"
            echo "  â€¢ pcr command : CrÃ©e la branche + fichier de commande + changelog"
            echo "  â€¢ pcr event   : CrÃ©e la branche + fichier d'Ã©vÃ©nement + changelog"
            echo ""
            echo "ğŸ¯ Utilisez 'pcr feature' pour des dÃ©veloppements gÃ©nÃ©raux"
            echo "   qui ne sont pas spÃ©cifiquement des commandes ou Ã©vÃ©nements Discord."
        fi
        ;;
    fix)
        validate_project_directory
        if [[ -n "$2" ]]; then
            create_fix_branch "$2"
        else
            print_error "Usage: pcr fix <nom_fix>"
            echo "Exemple: pcr fix login-validation-error"
            echo ""
            echo "Cette commande crÃ©e une nouvelle branche fix/<nom_fix>"
            echo "depuis main, pour corriger des bugs."
            echo ""
            echo "âš ï¸  Important:"
            echo "  â€¢ Les fixes ne sont PAS ajoutÃ©s au changelog automatiquement"
            echo "  â€¢ Mergez directement vers main une fois corrigÃ©"
            echo "  â€¢ Utilisez des messages de commit avec 'fix:' au dÃ©but"
            echo ""
            echo "ğŸ”§ Workflow suggÃ©rÃ©:"
            echo "  1. pcr fix mon-bug"
            echo "  2. Corriger le problÃ¨me" 
            echo "  3. git add . && git commit -m 'fix: correction du bug xyz'"
            echo "  4. git push -u origin fix/mon-bug"
            echo "  5. Merger directement vers main"
        fi
        ;;
    install)
        install_script
        ;;
    backup)
        validate_project_directory
        print_section "Sauvegarde de la Base de DonnÃ©es"
        if backup_database; then
            echo ""
            echo "ğŸ’¡ Commandes utiles:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ pcr restore <fichier>  - Restaurer une sauvegarde"
            echo "  â€¢ ls -la $BACKUP_DIR     - Voir toutes les sauvegardes"
        else
            echo ""
            echo "ğŸ” VÃ©rifications:"
            echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            echo "  â€¢ La base de donnÃ©es existe-t-elle?"
            echo "  â€¢ Le bot a-t-il Ã©tÃ© initialisÃ©? pcr deploy"
        fi
        ;;
    restore)
        validate_project_directory
        if [[ -n "$2" ]]; then
            print_section "Restauration de la Base de DonnÃ©es"
            restore_database "$2"
        else
            print_section "Sauvegardes Disponibles"
            if ls "$BACKUP_DIR"/*.db 1> /dev/null 2>&1; then
                ls -la "$BACKUP_DIR"/*.db
                echo ""
                echo "Usage: pcr restore <fichier_backup>"
                echo "Exemple:"
                echo "  pcr restore $BACKUP_DIR/$(ls "$BACKUP_DIR"/*.db 2>/dev/null | head -1 | xargs basename)"
            else
                print_warning "Aucune sauvegarde trouvÃ©e"
                echo ""
                echo "ğŸ’¡ Pour crÃ©er une sauvegarde:"
                echo "  pcr backup"
            fi
        fi
        ;;
    reset)
        # VÃ©rifier si l'option --y ou -y est prÃ©sente
        auto_confirm=false
        if [[ "$2" == "--y" ]] || [[ "$2" == "-y" ]]; then
            auto_confirm=true
        fi
        
        echo "ğŸ”„ RÃ©initialisation complÃ¨te du bot PCR..."
        echo ""
        echo -e "${YELLOW}âš ï¸  ATTENTION: Cette action va supprimer toutes les donnÃ©es!${NC}"
        echo -e "${YELLOW}âš ï¸  Les messages, configurations et donnÃ©es du bot seront perdues!${NC}"
        echo ""
        
        # Sauvegarde de sÃ©curitÃ© avant reset
        if [[ "$auto_confirm" != true ]]; then
            echo "ğŸ’¾ CrÃ©ation d'une sauvegarde de sÃ©curitÃ© avant reset..."
            backup_database || echo "Continuer sans sauvegarde..."
            echo ""
        fi
        
        if [ "$auto_confirm" = true ]; then
            echo "Mode automatique activÃ© (--y), confirmation ignorÃ©e"
            confirmation="o"
        else
            echo -n "ÃŠtes-vous sÃ»r de vouloir continuer? (O/n): "
            read -n 1 confirmation
            echo ""
        fi
        
        if [[ "$confirmation" =~ ^[Oo]$ ]] || [ -z "$confirmation" ]; then
            cd "$PROJECT_DIR" || {
                print_error "Impossible d'accÃ©der au rÃ©pertoire $PROJECT_DIR"
                exit 1
            }

            # Suppression des logs
            print_step "Suppression des logs..."
            if [ -d "$LOG_DIR" ]; then
                rm -rf "$LOG_DIR"/*
                print_success "Logs supprimÃ©s et rÃ©pertoire recrÃ©Ã©"
            else
                mkdir -p "$LOG_DIR"
            fi

            # Suppression de la base de donnÃ©es
            print_step "Suppression de la base de donnÃ©es..."
            db_path=$(find_database_path)
            if [[ -f "$db_path" ]]; then
                rm -f "$db_path"
                print_success "Base de donnÃ©es supprimÃ©e"
            fi

            # ArrÃªt et suppression du processus PM2
            print_step "ArrÃªt du processus PM2..."
            pm2 stop pcr 2>/dev/null || echo "Processus dÃ©jÃ  arrÃªtÃ©"
            pm2 delete pcr 2>/dev/null || echo "Processus non trouvÃ©"

            # RÃ©installation des dÃ©pendances
            print_step "RÃ©installation des dÃ©pendances..."
            rm -rf node_modules package-lock.json
            npm install

            # RedÃ©marrage
            print_step "RedÃ©marrage du bot..."
            pm2 start index.js --name pcr
            pm2 save
            
            sleep 2
            if check_app_status; then
                print_success "ğŸ‰ RÃ©initialisation terminÃ©e avec succÃ¨s!"
                print_success "Bot PCR redÃ©marrÃ© avec une configuration propre"
            else
                print_error "âŒ Erreur lors de la rÃ©initialisation"
            fi
        else
            print_warning "RÃ©initialisation annulÃ©e"
        fi
        ;;
    finish|finalize)
        validate_project_directory
        finalize_feature
        ;;
    release)
        validate_project_directory
        shift
        version_type="patch"
        title=""
        
        while [[ $# -gt 0 ]]; do
            case $1 in
                --type)
                    version_type="$2"
                    shift 2
                    ;;
                --title)
                    title="$2"
                    shift 2
                    ;;
                *)
                    print_error "Option inconnue: $1"
                    echo "Usage: pcr release [--type patch|minor|major] [--title \"Titre\"]"
                    exit 1
                    ;;
            esac
        done
        
        create_release "$version_type" "$title"
        ;;
    changelog-status)
        validate_project_directory
        print_section "Statut du Changelog"
        
        # CrÃ©er le script Node.js temporaire
        temp_script="/tmp/pcr_changelog_status_$$"
        cat > "$temp_script.js" << EOF
import { getChangelogStats } from '${PROJECT_DIR}/modules/version-manager.js';

try {
    const stats = getChangelogStats();
    
    if (stats.error) {
        console.log('âŒ Erreur:', stats.error);
        process.exit(1);
    }
    
    console.log('ğŸ“Š Statistiques du Changelog');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    console.log(\`ğŸ“¦ Version actuelle: \${stats.currentVersion}\`);
    console.log(\`ğŸ¯ Features en attente: \${stats.pendingFeatures}\`);
    console.log(\`ğŸ“‹ Total releases: \${stats.totalReleases}\`);
    
    if (stats.lastRelease) {
        console.log(\`ğŸ·ï¸  DerniÃ¨re release: \${stats.lastRelease.version} (\${stats.lastRelease.date})\`);
    }
    
    if (stats.pendingFeatures > 0) {
        console.log('\\nâ³ Features en attente par type:');
        Object.entries(stats.pendingByType).forEach(([type, count]) => {
            const icon = type === 'command' ? 'âš¡' : type === 'event' ? 'ğŸ¯' : 'âœ¨';
            console.log(\`   \${icon} \${type}: \${count}\`);
        });
    }
    
    console.log('\\nğŸ’¡ Commandes disponibles:');
    console.log('  â€¢ pcr finish     - Finaliser la feature actuelle');
    console.log('  â€¢ pcr release    - CrÃ©er une nouvelle release');
    
} catch (error) {
    console.error('âŒ Erreur:', error.message);
    process.exit(1);
}
EOF

        cd "$PROJECT_DIR"
        node "$temp_script.js"
        rm -f "$temp_script.js"
        ;;
    workflow)
        print_section "Guide de Workflow PCR"
        echo ""
        echo "ğŸš€ WORKFLOW DE DÃ‰VELOPPEMENT PCR"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "1ï¸âƒ£  CRÃ‰ER UNE NOUVELLE FEATURE:"
        echo "   pcr command --name ma-commande    # Pour une nouvelle commande"
        echo "   pcr event --name mon-event        # Pour un nouvel Ã©vÃ©nement"
        echo "   â””â”€ CrÃ©Ã© automatiquement une branche feature/type-nom"
        echo ""
        echo "2ï¸âƒ£  DÃ‰VELOPPER LA FEATURE:"
        echo "   â€¢ Modifiez le fichier gÃ©nÃ©rÃ©"
        echo "   â€¢ Testez avec: pcr restart && pcr logs"
        echo "   â€¢ Commitez vos changements au fur et Ã  mesure"
        echo ""
        echo "3ï¸âƒ£  FINALISER LA FEATURE:"
        echo "   pcr finish"
        echo "   â””â”€ Commit final + push + merge vers main + ajout au changelog"
        echo ""
        echo "4ï¸âƒ£  CRÃ‰ER UNE RELEASE:"
        echo "   pcr release --type patch          # Version x.x.X+1"
        echo "   pcr release --type minor          # Version x.X+1.0"
        echo "   pcr release --type major          # Version X+1.0.0"
        echo "   â””â”€ Publie toutes les features pending + tag Git + GitHub Actions"
        echo ""
        echo "ğŸ“Š VÃ‰RIFIER LE STATUT:"
        echo "   pcr changelog-status              # Voir les features en attente"
        echo "   pcr branches                      # Voir les branches actives"
        echo "   pcr status                        # Statut gÃ©nÃ©ral du bot"
        echo ""
        echo "ğŸ¯ GITHUB ACTIONS AUTOMATIQUES:"
        echo "   â€¢ Push d'un tag â†’ DÃ©clenche la release GitHub"
        echo "   â€¢ Release crÃ©Ã©e â†’ Publication automatique du changelog Discord"
        echo "   â€¢ Tests automatiques sur chaque push"
        echo ""
        echo "ğŸ’¡ BONNES PRATIQUES:"
        echo "   â€¢ Une feature = une branche"
        echo "   â€¢ Testez avant de finish"
        echo "   â€¢ Groupez plusieurs features dans une release"
        echo "   â€¢ Utilisez des messages de commit clairs"
        echo ""
        current_branch=$(git branch --show-current 2>/dev/null || echo "unknown")
        if [[ "$current_branch" != "main" ]] && [[ "$current_branch" != "master" ]]; then
            echo "ğŸ“ SITUATION ACTUELLE:"
            echo "   Branche: $current_branch"
            echo "   Action suggÃ©rÃ©e: pcr finish (quand ready)"
        fi
        ;;
    *)
        echo -e "${PURPLE}ğŸ¤– PCR BOT DISCORD - Script de gestion unifiÃ©${NC}"
        echo "============================================="
        echo ""
        echo "Usage: pcr [commande]"
        echo ""
        echo "Commandes disponibles:"
        echo ""
        echo "ğŸš€ Gestion du bot:"
        echo "  start         - DÃ©marre le bot"
        echo "  stop          - ArrÃªte le bot"
        echo "  restart       - RedÃ©marre le bot"
        echo "  status        - Affiche le statut du bot"
        echo ""
        echo "ğŸ“Š Monitoring et logs:"
        echo "  logs          - Affiche les logs PM2 du bot en temps rÃ©el"
        echo "  monitor       - Monitoring complet avec ressources systÃ¨me"
        echo ""
        echo "ğŸ”§ DÃ©veloppement:"
        echo "  dev           - Lance le bot en mode dÃ©veloppement (avec nodemon)"
        echo "  feature       - CrÃ©e une nouvelle branche feature (sans fichiers)"
        echo "                  Usage: pcr feature <nom_feature>"
        echo "  fix           - CrÃ©e une nouvelle branche fix (sans changelog)"
        echo "                  Usage: pcr fix <nom_fix>"
        echo "  command       - CrÃ©e une nouvelle commande Discord avec branche Git"
        echo "                  Usage: pcr command --name <nom> [--desc <description>] [--no-git]"
        echo "  event         - CrÃ©e un nouvel Ã©vÃ©nement Discord avec branche Git"
        echo "                  Usage: pcr event --name <nom> [--no-git]"
        echo "  branches      - Liste les branches de fonctionnalitÃ©s PCR"
        echo "  finish        - Finalise une feature branch (commit/merge/push)"
        echo "  release       - CrÃ©e une release avec changelog"
        echo "                  Usage: pcr release [--type patch|minor|major] [--title titre]"
        echo "  changelog-status - Affiche le statut du systÃ¨me de changelog"
        echo "  workflow      - Affiche le guide du workflow de dÃ©veloppement"
        echo ""
        echo "ğŸš€ DÃ©ploiement:"
        echo "  deploy        - DÃ©ploiement complet du bot"
        echo "  update        - Mise Ã  jour du bot depuis Git"
        echo ""
        echo "ğŸ’¾ Sauvegarde et restauration:"
        echo "  backup        - Sauvegarde la base de donnÃ©es"
        echo "  restore       - Restaure une sauvegarde (pcr restore <fichier>)"
        echo ""
        echo "âš™ï¸ Configuration:"
        echo "  install       - Installe le script dans le PATH global"
        echo "  reset         - RÃ©initialise complÃ¨tement le bot (âš ï¸ SUPPRIME TOUTES LES DONNÃ‰ES)"
        echo "                  Options: --y ou -y pour confirmer automatiquement"
        echo ""
        echo "Architecture:"
        echo "  ğŸ“ Bot Discord : PCR - Gestion communautaire"
        echo "  ğŸ“ Base de donnÃ©es : SQLite (messages.db)"
        echo "  ğŸ“ Logs : PM2 + fichiers locaux"
        echo ""
        exit 1
        ;;
esac
